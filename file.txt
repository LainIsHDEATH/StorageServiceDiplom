# ai_heater_service.py  (run with:  uvicorn ai_heater_service:app --port 7003)
import json, logging, math
import joblib
from pathlib import Path
from contextlib import asynccontextmanager
from typing import Dict, List, Tuple

import numpy as np                  # ───── ML stacks
import torch
import torch.nn as nn
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel, Field

# ────────────────────────────────────────────── settings
BASE_DIR = Path("models")           # expects room-{id}/model-{id}/...
SEQ_LENGTH = 30                     # <-- fixed during training
FEATURES   = 4

# ────────────────────────────────────────────── PyTorch net
class TemperatureLSTM(nn.Module):
    def __init__(self, input_size=FEATURES, hidden_size=128, num_layers=2):
        super().__init__()
        self.lstm = nn.LSTM(input_size, hidden_size, num_layers, batch_first=True)
        self.fc   = nn.Linear(hidden_size, 1)
    def forward(self, x):           # (N,L,F)
        out, _ = self.lstm(x)
        return self.fc(out[:,-1]).squeeze(-1)

# ────────────────────────────────────────────── DTOs
class LstmSensorDTO(BaseModel):
    tempIn:       float
    tempOut:      float
    tempSetpoint: float
    heaterPower:  float

class LstmModelDtoRequest(BaseModel):
    modelId: int
    sensorDataDTOList: List[LstmSensorDTO]

class LstmModelDtoResponse(BaseModel):
    predictedTemp: float

class RlModelDtoRequest(BaseModel):
    modelId: int = Field(..., alias="modelId")
    tempIn:  float = Field(..., alias="roomTemp")
    tempOut: float = Field(..., alias="outdoorTemp")

class RlModelDtoResponse(BaseModel):
    heater_power: float = Field(..., alias="heaterPower")

# ────────────────────────────────────────────── lifespan loader
@asynccontextmanager
async def lifespan(app: FastAPI):
    lstm_models: Dict[int, dict] = {}
    for ckpt in BASE_DIR.rglob("checkpoint.joblib"):
        meta = joblib.load(ckpt)                  # dict с ключами ниже
        mid = int(ckpt.parent.name.split("-")[1]) # .../model-{mid}/checkpoint.joblib

        # воссоздаём net с теми же hidden_size/num_layers
        net = TemperatureLSTM(
            input_size = FEATURES,
            hidden_size= meta["hidden_size"],
            num_layers = meta["num_layers"],
        )
        net.load_state_dict(meta["state_dict"])
        net.eval()

        # сохраняем bundle со всем нужным
        lstm_models[mid] = {
            "net":      net,
            "x_mean":   torch.tensor(meta["x_mean"]),
            "x_std":    torch.tensor(meta["x_std"]),
            "y_mean":    meta["y_mean"],
            "y_std":     meta["y_std"],
            "seq_len":   meta["seq_length"],
        }

    app.state.lstm_models = lstm_models


    # now also load RL tables
    rl_tables: Dict[int, np.ndarray] = {}
    for table_path in BASE_DIR.rglob("q_table.npy"):
        mid = int(table_path.parent.name.split("-")[1])  # folder is model-{mid}
        rl_tables[mid] = np.load(table_path)
    app.state.rl_tables = rl_tables
    yield

app = FastAPI(lifespan=lifespan)

# ────────────────────────────────────────────── routes
@app.post("/lstm/predict", response_model=LstmModelDtoResponse)
def lstm_predict(req: LstmModelDtoRequest):
    bundle = app.state.lstm_models.get(req.modelId)
    if not bundle:
        raise HTTPException(404, "Model not found")

    net     = bundle["net"]
    x_mean  = bundle["x_mean"]
    x_std   = bundle["x_std"]
    y_mean  = bundle["y_mean"]
    y_std   = bundle["y_std"]
    L       = bundle["seq_len"]

    window = req.sensorDataDTOList
    if len(window) < L:
        raise HTTPException(422, f"Need ≥{L} sensor records")

    # последние L точек
    data = window[-L:]
    # формируем тензор (1, L, FEATURES)
    import torch as _T
    feats = _T.tensor([[
        [d.tempIn, d.tempOut, d.tempSetpoint, d.heaterPower]
        for d in data
    ]], dtype=_T.float32)

    # нормализация по Z = (X - mean)/std
    feats_n = (feats - x_mean) / x_std

    # предсказание в норм-пространстве
    with torch.no_grad():
        pred_n = net(feats_n).item()

    # денормализация
    pred = pred_n * y_std + y_mean
    return {"predictedTemp": round(pred, 2)}

@app.post("/rl/compute", response_model=RlModelDtoResponse)
def rl_compute(req: RlModelDtoRequest):
    q = app.state.rl_tables.get(req.modelId)
    if q is None:
        raise HTTPException(404, "Model not found")
    q = app.state.rl_tables.get(req.modelId)
    if q is None:
        raise HTTPException(404, "Model not found")
    def bin(v, lo, hi, n=20): return int(np.clip((v-lo)/(hi-lo)*n, 0, n-1))
    s_r, s_o = bin(req.tempIn,10,30), bin(req.tempOut,-20,40)
    a_bin = q[s_r, s_o].argmax()
    pct   = a_bin/(q.shape[-1]-1)
    logging.info("Predicted temperature is %f", round(pct*100, 2))
    print("Calculated temmperature is %f", round(pct*100, 2))
    return {"heaterPower": round(pct*100, 2)}

# ----------------------------- Run ----------------------------------------
if __name__ == "__main__":
    import uvicorn
    uvicorn.run("ai_heater_service:app", host="0.0.0.0", port=7003, reload=True)

import json
import math
import joblib
import os
import time
from pathlib import Path
from typing import Optional

import logging
from logging.handlers import RotatingFileHandler

import numpy as np
import psycopg2
import requests
import torch
import torch.nn as nn
from fastapi import FastAPI, BackgroundTasks, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from torch.utils.data import DataLoader, TensorDataset
# -*- coding: utf-8 -*-
"""FastAPI-сервис обучения LSTM-модели для прогноза температуры.

Запускается командой:

    uvicorn lstm_service:app --host 0.0.0.0 --port 7001

После запуска принимает POST-запрос на /train c JSON-телом вида::

    {
        "roomId": 1,
        "simulationId": 149,
        "HIDDEN_SIZE": 128,
        "NUM_LAYERS": 2,
        "SEQ_LENGTH": 30,
        "batch_size": 64,
        "epochs_number": 50
    }

Сервис:
1. Забирает данные симуляции из PostgreSQL.
2. Формирует выборки, нормализует их и обучает LSTM.
3. Считает метрики на тесте.
4. Регистрирует модель во внешнем сервисе хранилища.
5. Сохраняет веса, данные и метрики в каталог models/room-{roomId}/model-{modelId}/.
"""

###############################################################################
# FastAPI и CORS
###############################################################################
app = FastAPI(title="Temperature LSTM Trainer")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

log_dir = Path("logs")
log_dir.mkdir(parents=True, exist_ok=True)

# Настройка логгера
logger = logging.getLogger("lstm_trainer")
logger.setLevel(logging.INFO)
fh = RotatingFileHandler("logs/training.log", maxBytes=5_000_000, backupCount=3, encoding="utf-8")
fmt = logging.Formatter("%(asctime)s — %(levelname)s — %(message)s", "%Y-%m-%d %H:%M:%S")
fh.setFormatter(fmt)
logger.addHandler(fh)
logger.addHandler(logging.StreamHandler())

###############################################################################
# Модель запроса
###############################################################################

class TrainRequest(BaseModel):
    roomId: int
    simulationId: int
    HIDDEN_SIZE: int
    NUM_LAYERS: int
    SEQ_LENGTH: int
    batch_size: int
    epochs_number: int

###############################################################################
# PyTorch‑модель
###############################################################################

class TemperatureLSTM(nn.Module):
    """Простая LSTM → Linear для регрессии температуры."""

    def __init__(self, input_size: int, hidden_size: int, num_layers: int):
        super().__init__()
        self.lstm = nn.LSTM(
            input_size=input_size,
            hidden_size=hidden_size,
            num_layers=num_layers,
            batch_first=True,
        )
        self.fc = nn.Linear(hidden_size, 1)

    def forward(self, x):
        # x shape: (batch, seq_length, input_size)
        lstm_out, _ = self.lstm(x)
        # Take output of last time step
        last_out = lstm_out[:, -1, :]  # shape: (batch, hidden_size)
        return self.fc(last_out).squeeze(-1)  # shape: (batch, 1)

###############################################################################
# Вспомогательные функции
###############################################################################

def get_db_connection():
    """Создаём соединение с БД из переменных окружения."""

    return psycopg2.connect(
        host=os.getenv("DB_HOST", "localhost"),
        port=os.getenv("DB_PORT", "5433"),
        dbname=os.getenv("DB_NAME", "storagedb"),
        user=os.getenv("DB_USER", "postgres"),
        password=os.getenv("DB_PASSWORD", "postgres"),
    )


def fetch_simulation(sim_id: int) -> np.ndarray:
    """Читаем данные симуляции из таблицы simulations.simulation_events."""

    with get_db_connection() as conn:
        with conn.cursor() as cur:
            cur.execute(
                """
                SELECT temp_in, temp_out, heater_power, temp_setpoint
                FROM simulations.simulation_events
                WHERE simulation_id = %s
                ORDER BY timestamp
                """,
                (sim_id,),
            )
            rows = cur.fetchall()
    if not rows:
        raise ValueError("Нет данных для simulation_id = %s" % sim_id)
    return np.asarray(rows, dtype=np.float32)


def make_sequences(data: np.ndarray, seq_len: int):
    """Преобразуем матрицу (N, F) в обучающие последовательности."""

    n = data.shape[0] - seq_len
    X = np.stack([data[i : i + seq_len] for i in range(n)])  # (n, seq, F)
    y = data[seq_len:, 0]  # temp_in следующего шага
    return X, y


def train_val_test_split(X, y, train=0.7, val=0.15):
    """Делим массивы без перемешивания по времени."""

    n = len(X)
    n_train = int(n * train)
    n_val = int(n * val)
    X_tr, y_tr = X[:n_train], y[:n_train]
    X_val, y_val = X[n_train : n_train + n_val], y[n_train : n_train + n_val]
    X_te, y_te = X[n_train + n_val :], y[n_train + n_val :]
    return (X_tr, y_tr), (X_val, y_val), (X_te, y_te)


def normalise_sets(train_X, *other_sets):
    """Z‑score нормализация по статистике train_set."""

    mean = train_X.reshape(-1, train_X.shape[-1]).mean(0)
    std = train_X.reshape(-1, train_X.shape[-1]).std(0)
    std[std == 0] = 1.0

    res = [(train_X - mean) / std]
    for s in other_sets:
        res.append((s - mean) / std)
    return res, mean, std  # вернём статистику для temp_in

def evaluate(model, X, y, y_mean, y_std, batch=64):
    model.eval()
    dev = next(model.parameters()).device
    total_mae = 0.0
    total_mse = 0.0
    n = len(X)
    with torch.no_grad():
        for i in range(0, n, batch):
            xb = torch.tensor(X[i : i + batch], device=dev)
            # отримаємо нормовані передбачення
            pred_n = model(xb).cpu().numpy()
            # денормалізуємо
            pred   = pred_n * y_std + y_mean
            err    = y[i : i + batch] - pred
            total_mae += np.abs(err).sum()
            total_mse += (err ** 2).sum()
    mae  = total_mae / n
    mse  = total_mse / n
    rmse = math.sqrt(mse)
    return mae, mse, rmse


###############################################################################
# Основной эндпоинт
###############################################################################

def train_sync(req: TrainRequest):
    """Обучает LSTM по данным симуляции и регистрирует модель."""

    # 1. Читаем данные симуляции ------------------------------------------------
    try:
        data = fetch_simulation(req.simulationId)
    except Exception as exc:
        raise HTTPException(500, f"Ошибка БД: {exc}")

    # 2. Формируем последовательности ------------------------------------------
    try:
        X, y = make_sequences(data, req.SEQ_LENGTH)
    except ValueError:
        raise HTTPException(400, "Недостаточно точек для заданной длины окна")

    # 3. Делим на train/val/test и нормализуем ----------------------------------
    (X_tr, y_tr), (X_val, y_val), (X_te, y_te) = train_val_test_split(X, y)
    (X_tr_n, X_val_n, X_te_n), x_mean, x_std = normalise_sets(X_tr, X_val, X_te)

    y_mean = float(x_mean[0])
    y_std = float(x_std[0])

    y_tr_n = (y_tr - y_mean) / y_std
    y_val_n = (y_val - y_mean) / y_std

    # 4. TensorDataset/DataLoader ----------------------------------------------
    def loader(X_, y_, shuffle):
        if len(X_) == 0:
            return None
        dset = TensorDataset(torch.tensor(X_), torch.tensor(y_))
        return DataLoader(dset, batch_size=req.batch_size, shuffle=shuffle)

    dl_train = loader(X_tr_n, y_tr_n, True)
    dl_val = loader(X_val_n, y_val_n, False)

    # 5. Модель, лосс, оптимизатор ---------------------------------------------
    device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')  # при наличии GPU можно переключить
    model = TemperatureLSTM(X.shape[-1], req.HIDDEN_SIZE, req.NUM_LAYERS).to(device)
    criterion = nn.MSELoss()
    optim = torch.optim.Adam(model.parameters(), lr=1e-3)
    best_state: Optional[dict] = None
    best_val = float("inf")

    # 6. Обучение ---------------------------------------------------------------
    for epoch in range(1, req.epochs_number + 1):
        model.train()
        train_losses = []
        for xb, yb in dl_train:
            xb, yb = xb.to(device), yb.to(device)
            optim.zero_grad()
            pred = model(xb)
            loss = criterion(pred, yb)
            loss.backward()
            optim.step()
            train_losses.append(loss.item())
        train_loss = sum(train_losses) / len(train_losses)
        val_loss = None
        if dl_val:
            model.eval()
            with torch.no_grad():
                val_loss = sum(
                    criterion(model(xb.to(device)), yb.to(device)).item()
                    for xb, yb in dl_val
                ) / len(dl_val)

        # якщо знайшли кращу меру – зберігаємо снапшот
        if val_loss is not None and val_loss < best_val:
            best_val = val_loss
            best_state = {k: v.cpu().clone() for k, v in model.state_dict().items()}

        logger.info(f"Epoch {epoch:3}: Train={train_loss:.6f}  Val={val_loss:.6f}")

    if best_state:
        model.load_state_dict(best_state)

    # 7. Тест и метрики ---------------------------------------------------------
    model.to('cpu')
    torch.cuda.empty_cache()
    device = torch.device('cpu')

    # Викликаємо нашу evaluate-функцію
    mae, mse, rmse = evaluate(
        model,
        X_te_n,  # нормалізовані X для тесту
        y_te,  # справжні (ненормовані) y
        y_mean,
        y_std,
        batch=int(req.batch_size / 2)  # наприклад, подвоєний розмір батчу
    )

    # R^2 все ще вираховуємо тут
    preds_n = model(torch.tensor(X_te_n, device=device)).detach().cpu().numpy()
    preds = preds_n * y_std + y_mean
    trues = y_te
    r2 = float(1 - ((trues - preds) ** 2).sum() / ((trues - trues.mean()) ** 2).sum())

    # 8. Регистрация модели -----------------------------------------------------
    store_api = os.getenv("STORE_API", "http://localhost:8082/api")
    payload = {
        "id": req.roomId,
        "type": "LSTM",
        "path": None,
        "description": json.dumps(
            {
                "simulationId": req.simulationId,
                "HIDDEN_SIZE": req.HIDDEN_SIZE,
                "NUM_LAYERS": req.NUM_LAYERS,
                "SEQ_LENGTH": req.SEQ_LENGTH,
                "batch_size": req.batch_size,
                "epochs_number": req.epochs_number,
            }
        ),
        "active": True,
    }
    try:
        r = requests.post(f"{store_api}/models/room-models/{req.roomId}", json=payload)
        r.raise_for_status()
        model_id = r.json().get("id") or r.json().get("modelId")
    except Exception as exc:
        base = Path(f"models/exception")
        base.mkdir(parents=True, exist_ok=True)
        torch.save(model.state_dict(), base / "model.pth")
        np.save(base / "X.npy", X)  # оригинальные (ненорм) последовательности
        np.save(base / "Y.npy", y)
        with open(base / "metrics.txt", "w", encoding="utf-8") as f:
            f.write(f"MAE={mae:.4f}\nMSE={mse:.4f}\nRMSE={rmse:.4f}\nR2={r2:.4f}\n")
        raise HTTPException(500, f"Не удалось зарегистрировать модель в БД: {exc}")

    # 9. Сохранение файлов ------------------------------------------------------
    base = Path(f"models/room-{req.roomId}/model-{model_id}")
    base.mkdir(parents=True, exist_ok=True)

    meta = {
        "hidden_size": req.HIDDEN_SIZE,
        "num_layers": req.NUM_LAYERS,
        "seq_length": req.SEQ_LENGTH,
        "state_dict": model.state_dict(),
        "x_mean": x_mean,  # shape = (4,)
        "x_std": x_std,  # shape = (4,)
        "y_mean": y_mean,  # скаляр
        "y_std": y_std,  # скаляр
    }
    joblib.dump(meta, base / "checkpoint.joblib")

    torch.save(model.state_dict(), base / "model.pth")

    with open(base / "metrics.txt", "w", encoding="utf-8") as f:
        f.write(f"MAE={mae:.4f}\nMSE={mse:.4f}\nRMSE={rmse:.4f}\nR2={r2:.4f}\n")

    return {
        "modelId": model_id,
        "metrics": {"MAE": mae, "MSE": mse, "RMSE": rmse, "R2": r2},
    }

@app.post("/train")
async def train(
    req: TrainRequest,
    background_tasks: BackgroundTasks
):
    """
    Асинхронный эндпоинт: принимает запрос и сразу же запускает
    train_sync в фоне, не блокируя основной поток.
    """
    # Можно сгенерировать свой job_id, если нужно отслеживать статус:
    job_id = f"{req.roomId}-{req.simulationId}-{int(time.time())}"
    # Запускаем фоновую задачу
    background_tasks.add_task(train_sync, req)
    # Мгновенно отвечаем клиенту, что обучение запущено
    return {
        "status": "training_started",
        "job_id": job_id,
        "roomId": req.roomId,
        "simulationId": req.simulationId,
    }


###############################################################################
# Точка входа для локального запуска
###############################################################################

if __name__ == "__main__":
    import uvicorn

    uvicorn.run("lstm_service:app", host="0.0.0.0", port=7001, reload=True)


import os, time, uuid, requests, pandas as pd
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel, Field
from typing import Dict, List
from fastapi.middleware.cors import CORSMiddleware

from tune_fopdt import identify_fopdt, cohen_coon   # <-- helper

SIM_API   = os.getenv("SIM_API",   "http://localhost:8080/api")
STORE_API = os.getenv("STORE_API", "http://localhost:8082/api")
SELF_HOST = os.getenv("SELF_HOST", "http://localhost:7000")

DELTA_PC  = 10.0
PERIOD_S  = 900
DT_S      = 60

app = FastAPI(title="PID-autotune-service")

app.add_middleware(
    CORSMiddleware,
    allow_origins=[          # домены, с которых разрешаем JS-запросы
        "*"   # React dev-сервер
    ],
    allow_credentials=True,        # если нужен cookie / auth-header
    allow_methods=["*"],           # или ['POST', 'GET', 'OPTIONS']
    allow_headers=["*"],           # Content-Type, Authorization, …
)

# -------- Pydantic модели – 1 к 1 с Java DTO -------------------
class AutotunePidSimulationDtoRequest(BaseModel):
    roomId:          int
    controllerType:  str   = "AUTOTUNE_PID"
    iterations:      int
    timestepSeconds: int
    deltaPc: float = Field(..., alias="deltaPc")
    periodSeconds: int = Field(..., alias="period")

class AutotunePidDtoRequest(BaseModel):
    roomTemp: float

class AutotunePidDtoResponse(BaseModel):
    outputPower: float

# -------- сессия ----------------------------------------------
class Session:
    def __init__(self, room_id: int, iterations: int, timestepSeconds: int = DT_S, deltaPc: float = DELTA_PC, periodSeconds: int = PERIOD_S):
        self.id       = str(0)
        self.room_id  = room_id
        self.N        = iterations           # сколько тикoв пришлёт симулятор
        self.timestepSeconds = timestepSeconds
        self.deltaPc = deltaPc
        self.periodSeconds = periodSeconds
        self.log: List[tuple] = []           # (t,power,temp)
        self.start_ts = time.time()
        self.done     = False
        self.kp = self.ki = self.kd = None

    def relay_power(self) -> float:
        sign = 1 if int((time.time()-self.start_ts)//self.periodSeconds) % 2 == 0 else -1
        return sign * self.deltaPc

    def append(self, p, T):                      # t – относит. сек
        self.log.append((time.time()-self.start_ts, p, T))

    # когда получили N точек – завершаем
    def finished(self) -> bool:
        return len(self.log) >= self.N

    # считать PID + отправить в БД-сервис
    def compute_and_store(self):
        if self.done:
            return
        df = pd.DataFrame(self.log, columns=["timestamp", "power", "temp"])
        K, tau, theta     = identify_fopdt(df)
        self.kp, self.ki, self.kd = cohen_coon(K, tau, theta)
        self.done = True

        dto = {
            "kp": self.kp, "ki": self.ki, "kd": self.kd,
            "tunedMethod": "CohenCoon",
            "active": True
        }
        print(dto)
        print(self.room_id)
        url = f"{STORE_API}/pid-configs/room-configs/{self.room_id}"
        try:
            requests.post(url, json=dto, timeout=5)
        except Exception as exc:
            print("STORE POST failed:", exc)

# -------- глобальное хранилище сессий --------------------------
sessions: Dict[str, Session] = {}

# 1. клиент (Spring-сервис) запускает автотюн
@app.post("/autotune")
def autotune(req: AutotunePidSimulationDtoRequest):
    # 1. формируем payload БЕЗ callback (его мы ещё не знаем)
    sim_payload = {
        "roomId": req.roomId,
        "controllerType": req.controllerType,
        "iterations": req.iterations,
        "timestepSeconds": req.timestepSeconds
    }

    # 2. стартуем симуляцию и получаем simulationId
    try:
        resp = requests.post(
            f"{SIM_API}/simulations/autotune/cohen-coon",
            json=sim_payload, timeout=5
        )
        resp.raise_for_status()
    except Exception as exc:
        raise HTTPException(502, f"simulator unavailable: {exc}")

    simulation_id = resp.json().get("simulationId")
    if simulation_id is None:
        raise HTTPException(502, "simulator did not return simulationId")

    # 3. регистрируем сессию в словаре
    s = Session(req.roomId, req.iterations)
    sessions[simulation_id] = s  # ключ – simulationId
    return {"session_id": simulation_id}

# 2. симулятор каждый тик: присылает Т, получает U
@app.post("/api/power/{simulationId}", response_model=AutotunePidDtoResponse)
def power(
    simulationId: int,                # ❷ имя и тип совпадают с path-param
    upd: AutotunePidDtoRequest
):
    s = sessions.get(simulationId)    # ❸ тот же ключ
    if not s:
        raise HTTPException(404, "session not found")

    # если автотюн завершён – отдаём «0» и больше не пишем в лог
    if s.done:
        return AutotunePidDtoResponse(outputPower=0.0)

    p = s.relay_power()
    s.append(p, upd.roomTemp)

    if s.finished():
        s.compute_and_store()
        return AutotunePidDtoResponse(outputPower=0.0)

    return AutotunePidDtoResponse(outputPower=p)

# tune_fopdt.py
"""
Нужный минимум:  ► identify_fopdt           (35 % / 85 %  + оптимизация)
                ► cohen_coon               (формулы CC-PID)
"""
import numpy as np
import pandas as pd
from scipy.optimize import minimize

# ---------- FOPDT идентификация ------------------------------------------
def _fopdt_response(t, K, tau, theta):
    """Единичный ступенчатый отклик FOPDT (gain=K, time-const=tau, dead-time=theta)."""
    y = K * (1 - np.exp(-(t - theta) / tau))
    y[t < theta] = 0.0
    return y

def identify_fopdt(df: pd.DataFrame):
    """
    Вернёт (K, tau, theta) для лога step-теста.
    df must contain columns ["timestamp","power","temp"].
    """
    t     = df["timestamp"].values - df["timestamp"].values[0]
    pv    = df["temp"].values
    cv    = df["power"].values

    du    = cv.max() - cv.min()          # величина ступени
    dy    = pv[-1]  - pv[0]
    K0    = dy / du if du else 1.0       # грубая оценка gain
    tau0  = t[np.argmin(np.abs(pv - (pv[0] + 0.632*dy)))]  # ~63 %
    theta0= t[np.argmax(np.diff(pv))] / 2                  # пол-упрощённо

    def err(params):
        K, tau, theta = params
        y_hat = _fopdt_response(t, K, tau, theta) * du + pv[0]
        return np.sum(np.abs(y_hat - pv))          # IAE

    bounds = [(1e-6, None), (1e-3, None), (0.0, max(t))]
    K, tau, theta = minimize(err, (K0, tau0, theta0), bounds=bounds).x
    return float(K), float(tau), float(theta)

# ---------- Коэн-Кун (PID) ------------------------------------------------
def cohen_coon(K, tau, theta):
    """
    Возвращает kp, ki, kd (independent form, sec) для FOPDT модели.
    """
    if theta <= 0 or tau <= 0:
        raise ValueError("tau and theta must be >0")

    r  = theta / tau
    kp = (1 / K) * (1.35 + 0.27 * r) / r
    Ti = tau * (2.5 + 0.66 * r) / (1 + 0.444 * r)   # sec
    Td = 0.37 * tau / (1 + 0.2 * r)                 # sec

    ki = kp / Ti
    kd = kp * Td
    return kp, ki, kd

"""Полностью самодостаточный FastAPI‑сервис для обучения Q‑learning‑агента
(исправленная версия).

Основные фиксы против предыдущей ревизии
---------------------------------------
1. **Корректное Q‑обучение.** Теперь learn() получает _разные_ state и
   next_state. Логика: во время вызова /compute у нас уже есть новое
   состояние, возникшее после применения **предыдущего** действия; именно для
   него и вычисляется награда.
2. **Храним переходы между вызовами**. Для каждого simulationId в памяти
   хранится prev_state, prev_action, prev_pct, prev_setpoint; на базе
   этих данных считаем reward и делаем шаг Q‑learning.
3. **Возврат model_id** из _persist_model и лог‑сообщения при ошибках.
4. **Таймаут тренера** (optional): если 30 минут не приходит ни одного запроса,
   тренер удаляется, чтобы не висеть в памяти навечно.
5. Мелкие стилистические и typing‑улучшения.
"""
from __future__ import annotations

import asyncio
import logging
import os
import uuid
from contextlib import asynccontextmanager
from pathlib import Path
from typing import Dict, Tuple, Optional

import httpx
import numpy as np
from fastapi import BackgroundTasks, FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, Field

# ---------------------------------------------------------------------------
# Константы окружения и директории
# ---------------------------------------------------------------------------
SIM_API = os.getenv("SIM_API", "http://localhost:8080/api")
STORE_API = os.getenv("STORE_API", "http://localhost:8082/api")
BASE_DIR = Path(os.getenv("MODELS_DIR", "models"))
BASE_DIR.mkdir(parents=True, exist_ok=True)

TRAINER_TTL_SEC = 30 * 60  # 30 минут бездействия → выгрузить

# ---------------------------------------------------------------------------
# Логирование
# ---------------------------------------------------------------------------
logging.basicConfig(
    format="%(asctime)s — %(levelname)s — %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S",
    level=logging.INFO,
)
logger = logging.getLogger("rl_trainer")

# ---------------------------------------------------------------------------
# Q‑learning агент
# ---------------------------------------------------------------------------
class QLearningAgent:
    """Простая Q‑таблица c двухмерным состоянием (room_t, outdoor_t)."""

    def __init__(
        self,
        n_bins: int = 31,
        total_steps: int = 10_000,
        lr: float = 0.3,
        gamma: float = 0.99,
        eps: float = 1.0,
    ) -> None:
        self.n_bins = n_bins
        self.q_table = np.zeros((n_bins, n_bins, n_bins), dtype=np.float32)

        self.lr = lr
        self.gamma = gamma
        self.eps = eps
        self.global_step = 0
        self.total_steps = total_steps

        self.episode_return = 0.0
        self.returns: list[dict] = []
        self.last_total: Optional[float] = None
        self.last_avg: Optional[float] = None
        self.last_steps: Optional[int] = None

    # ------------------- дискретизация ----------------------------------
    @staticmethod
    def _bin(value: float, v_min: float, v_max: float, n: int) -> int:
        return int(np.clip((value - v_min) / (v_max - v_min) * n, 0, n - 1))

    def _state(self, room_t: float, out_t: float) -> Tuple[int, int]:
        return (
            self._bin(room_t, 10.0, 30.0, self.n_bins),
            self._bin(out_t, -10.0, 30.0, self.n_bins),
        )

    # ------------------- политика ---------------------------------------
    def act(self, room_t: float, out_t: float) -> Tuple[float, Tuple[int, int], int]:
        room_bin, out_bin = self._state(room_t, out_t)
        if np.random.rand() < self.eps:
            action_bin = np.random.randint(self.n_bins)
        else:
            action_bin = int(np.argmax(self.q_table[room_bin, out_bin]))
        pct = action_bin / (self.n_bins - 1)
        return pct, (room_bin, out_bin), action_bin

    # ------------------- обучение ---------------------------------------
    def learn(
        self,
        state: Tuple[int, int],
        action_bin: int,
        reward: float,
        next_state: Tuple[int, int],
    ) -> bool:
        s_r, s_o = state
        ns_r, ns_o = next_state

        best_next = float(np.max(self.q_table[ns_r, ns_o]))
        td_error = reward + self.gamma * best_next - self.q_table[s_r, s_o, action_bin]
        self.q_table[s_r, s_o, action_bin] += self.lr * td_error

        self.global_step += 1
        self.eps = max(0.01, self.eps * 0.995)  # эксп. спад

        self.episode_return += reward
        done = self.global_step >= self.total_steps - 1
        if done:
            avg = self.episode_return / self.global_step
            self.returns.append(
                {"total": self.episode_return, "avg": avg, "steps": self.global_step}
            )
            self.last_total = self.episode_return
            self.last_avg = avg
            self.last_steps = self.global_step
        return done

# ---------------------------------------------------------------------------
# Pydantic‑схемы
# ---------------------------------------------------------------------------
class TrainRequest(BaseModel):
    room_id: int = Field(..., alias="roomId")
    iterations: int
    timestep_seconds: int = Field(..., alias="timestepSeconds")
    lr: float
    gamma: float
    eps: float

class TrainReply(BaseModel):
    message: str
    simulationId: int
    job_id: str

class ComputeRequest(BaseModel):
    simulation_id: int = Field(..., alias="simulationId")
    room_temp: float = Field(..., alias="roomTemp")
    outdoor_temp: float = Field(..., alias="outdoorTemp")
    setpoint_temp: float = Field(..., alias="setpointTemp")

class ComputeReply(BaseModel):
    heaterPower: float  # 0–100 %

# ---------------------------------------------------------------------------
# FastAPI – lifespan & helpers
# ---------------------------------------------------------------------------
@asynccontextmanager
async def lifespan(app: FastAPI):
    app.state.trainers: Dict[int, Dict] = {}
    logger.info("RL‑trainer service started")
    yield

app = FastAPI(title="RL Trainer", lifespan=lifespan)
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# ----------------------------- /train ------------------------------------
@app.post("/train", response_model=TrainReply)
async def train(req: TrainRequest, bg: BackgroundTasks):
    async with httpx.AsyncClient() as client:
        resp = await client.post(
            f"{SIM_API}/simulations/train-rl",
            json={
                "roomId": req.room_id,
                "controllerType": "TRAIN_RL",
                "iterations": req.iterations,
                "timestepSeconds": req.timestep_seconds,
            },
            timeout=10,
        )
        resp.raise_for_status()
        data = resp.json()
        sim_id = (
            data.get("simulationId")
            or data.get("simulation_id")
            or data.get("id")
            or (data.get("data") or {}).get("id")
        )

    if sim_id in app.state.trainers:
        raise HTTPException(400, "Trainer already exists for this simulation")

    agent = QLearningAgent(
        n_bins=30,
        total_steps=req.iterations,
        lr=req.lr,
        gamma=req.gamma,
        eps=req.eps,
    )

    app.state.trainers[sim_id] = {
        "agent": agent,
        "room_id": req.room_id,
        "lr": req.lr,
        "gamma": req.gamma,
        "eps": req.eps,
        "prev_state": None,
        "prev_action": None,
        "prev_pct": None,
        "prev_setpoint": None,
        "last_touch": asyncio.get_event_loop().time(),
    }
    job_id = str(uuid.uuid4())
    logger.info("Trainer started for simulation %s (room %s)", sim_id, req.room_id)
    return {"message": "Training initialized", "simulationId": sim_id, "job_id": job_id}

# ----------------------------- /compute ----------------------------------
@app.post("/compute", response_model=ComputeReply)
async def compute(step: ComputeRequest):
    entry = app.state.trainers.get(step.simulation_id)
    if not entry:
        raise HTTPException(404, "No active trainer for this simulation")

    now = asyncio.get_event_loop().time()
    entry["last_touch"] = now  # обновляем «активность»

    agent: QLearningAgent = entry["agent"]

    current_state = agent._state(step.room_temp, step.outdoor_temp)
    if entry["prev_state"] is not None:
        reward = -abs(entry["prev_setpoint"] - step.room_temp) - 0.04 * entry["prev_pct"]
        done = agent.learn(entry["prev_state"], entry["prev_action"], reward, current_state)
        if done:
            await _finish_training(step.simulation_id, entry)
            pct = 0.0
            return ComputeReply(heaterPower=pct * 100)

    # ================= 2.   выбираем НОВОЕ действие =======================
    pct, state_bins, action_bin = agent.act(step.room_temp, step.outdoor_temp)

    # сохраняем «текущее» как «предыдущее» для следующего шага
    entry["prev_state"] = state_bins
    entry["prev_action"] = action_bin
    entry["prev_pct"] = pct
    entry["prev_setpoint"] = step.setpoint_temp

    return ComputeReply(heaterPower=pct * 100)

# ------------------------- helper: завершение ----------------------------
async def _finish_training(sim_id: int, entry: Dict) -> None:
    agent: QLearningAgent = entry["agent"]
    room_id = entry["room_id"]

    model_id = await _persist_model(
        sim_id,
        room_id,
        agent.q_table,
        agent.last_total or 0.0,
        agent.last_avg or 0.0,
        agent.returns,
        entry["lr"],
        entry["gamma"],
        entry["eps"],
    )
    logger.info("Model %s for room %s saved, trainer removed", model_id, room_id)
    app.state.trainers.pop(sim_id, None)

# ----------------------------- Persist -----------------------------------
async def _persist_model(
    sim_id: int,
    room_id: int,
    q_table: np.ndarray,
    total_return: float,
    avg_return: float,
    episode_log: list[dict],
    lr: float,
    gamma: float,
    eps: float,
) -> str:
    """Регистрирует модель и сохраняет Q‑таблицу на диск."""
    try:
        async with httpx.AsyncClient() as client:
            resp = await client.post(
                f"{STORE_API}/models/room-models/{room_id}",
                json={
                    "type": "RL",
                    "description": (
                        f"| 2-D Q-table (sim {sim_id}) | "
                        f"lr={lr:.3f}, gamma={gamma:.3f}, eps={eps:.3f} |"
                        f"total={total_return:.1f}, avg={avg_return:.3f} |"
                    ),
                },
                timeout=10,
            )
            resp.raise_for_status()
            model_id = resp.json().get("id") or resp.json().get("modelId")
    except Exception as exc:
        logger.info("STORE_API error: %s", exc)
        model_id = "error"

    out_dir = BASE_DIR / f"room-{room_id}" / f"model-{model_id}"
    out_dir.mkdir(parents=True, exist_ok=True)
    try:
        np.save(out_dir / "q_table.npy", q_table)
        with open(out_dir / "reward.txt", "w", encoding="utf-8") as f:
            f.write(f"total_return={total_return:.4f}\n")
            f.write(f"avg_return={avg_return:.4f}\n")
            f.write(f"episodes={len(episode_log)}\n")
            f.write("log=" + repr(episode_log) + "\n")
    except Exception as exc:
        logger.info("Error saving model to disk: %s", exc)
    return str(model_id)

# ---------------------------------------------------------------------------
# Background task: чистка неактивных тренеров
# ---------------------------------------------------------------------------
async def _trainer_gc(app: FastAPI):
    while True:
        await asyncio.sleep(60)
        now = asyncio.get_event_loop().time()
        to_del = [sid for sid, e in app.state.trainers.items() if now - e["last_touch"] > TRAINER_TTL_SEC]
        for sid in to_del:
            logger.info("Trainer %s removed due to inactivity", sid)
            app.state.trainers.pop(sid, None)

@app.on_event("startup")
async def _start_gc():
    asyncio.create_task(_trainer_gc(app))

# ---------------------------------------------------------------------------
# Запуск через python rl_trainer_service.py
# ---------------------------------------------------------------------------
if __name__ == "__main__":
    import uvicorn

    uvicorn.run("rl_trainer_service:app", host="0.0.0.0", port=7002, reload=True)

const API_BASE = 'http://localhost:8082/api'; // базовый путь к backend API

export const login = async ({ email, password }) => {
  const res = await fetch(${API_BASE}/users/login, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ email, password })
  });
  if (!res.ok) {
    throw new Error('Auth error');
  }
  return res.json(); // ожидаем { user, token }
};

export const register = async ({ username, email, password }) => {
  const res = await fetch(${API_BASE}/users/register, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ username, email, password })
  });
  if (!res.ok) {
    throw new Error('Auth error');
  }
  return res.json();
};

export const TRAIN_LSTM_API = 'http://localhost:7001/train';   // FastAPI srv
export const TRAIN_RL_API   = 'http://localhost:7002/train';   // RL trainer

const API_BASE        = 'http://localhost:8082/api';
export const TRAIN_LSTM_API = 'http://localhost:7001/train';   // FastAPI trainer
export const TRAIN_RL_API   = 'http://localhost:7002/train';   // RL trainer

/* ─────────────────────── list models ─────────────────────── */
export const getModels = async (roomId) => {
  const res = await fetch(${API_BASE}/models/room-models/${roomId});
  if (!res.ok) throw new Error('Could not load models');
  const json = await res.json();
  return Array.isArray(json.models) ? json.models : json;
};

/* ─────────────────────── train LSTM ──────────────────────── */
export const createLstmModel = async ({
                                        roomId,
                                        simulationId,
                                        HIDDEN_SIZE,
                                        NUM_LAYERS,
                                        SEQ_LENGTH,
                                        batch_size,
                                        epochs_number,
                                      }) => {
  const res = await fetch(TRAIN_LSTM_API, {
    method : 'POST',
    headers: { 'Content-Type': 'application/json' },
    body   : JSON.stringify({
      roomId,
      simulationId,
      HIDDEN_SIZE,
      NUM_LAYERS,
      SEQ_LENGTH,
      batch_size,
      epochs_number,
    }),
  });
  if (!res.ok) throw new Error('LSTM training failed');
  return res.json();                     // { modelId, metrics:{…} }
};

/* ─────────────────────── train RL ────────────────────────── */
export async function createRlModel(roomId, {  iterations, timestepSeconds, lr, gamma, eps  }) {
  const res = await fetch('http://localhost:7002/train', {
    method : 'POST',
    headers: { 'Content-Type': 'application/json' },
    body   : JSON.stringify({
      roomId,                    // ← додали
      controllerType  : 'TRAIN_RL',
      iterations,
      timestepSeconds,
      lr,
      gamma,
      eps
    })
  });

  if (!res.ok) {
    const msg = await res.text();
    throw new Error(RL training failed: ${msg});
  }
  return res.json();
}
/* ─────────────────────── activate model ─────────────────── */
export const setModelActive = async (roomId, modelId) => {
  const res = await fetch(
    ${API_BASE}/rooms/${roomId}/models/${modelId}/activate,
    { method: 'POST' }
  );
  if (!res.ok) throw new Error('Failed to activate model');
  const json = await res.json();
  return Array.isArray(json.models) ? json.models : json;
};

const API_BASE = 'http://localhost:8082/api';
const AUTOTUNE_API_BASE = 'http://localhost:7000';

export const getPIDConfigs = async (roomId) => {
  const res = await fetch(${API_BASE}/pid-configs/room-configs/${roomId}, {
    // headers: {
    //   'Authorization': Bearer ${localStorage.getItem('token')}
    // }
  });
  if (!res.ok) {
    throw new Error('Не удалось получить PID-конфигурации');
  }
  const json = await res.json();
  return Array.isArray(json.configs) ? json.configs : json; // ожидаем массив конфигураций {id, kp, ki, kd, tunedMethod, isActive}
};

export const createPIDConfig = async (roomId, config) => {
  const res = await fetch(${API_BASE}/pid-configs/room-configs/${roomId}, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      // 'Authorization': Bearer ${localStorage.getItem('token')}
    },
    body: JSON.stringify(config) // { kp, ki, kd, tunedMethod }
  });
  if (!res.ok) {
    throw new Error('Не удалось добавить PID-конфигурацию');
  }
  const json = await res.json();
  return Array.isArray(json.configs) ? json.configs : json;
};

export const setPIDActive = async (roomId, configId) => {
  const res = await fetch(${API_BASE}/pid-configs/room-configs/${roomId}/${configId}/activate, {
    method: 'POST',
    // headers: {
    //   'Authorization': Bearer ${localStorage.getItem('token')}
    // }
  });
  if (!res.ok) {
    throw new Error('Не удалось установить активную конфигурацию');
  }
  return res.json();
};

export async function autoTunePid(roomId, payload) {
  const res = await fetch(
    ${AUTOTUNE_API_BASE}/autotune, {
      method : 'POST',
      headers: { 'Content-Type': 'application/json' },
      body   : JSON.stringify({ roomId, controllerType: 'AUTOTUNE_PID', ...payload })
    });
  if (!res.ok) throw new Error('Автотюн не запустился');
  return res.json();        // { session_id: ... }
}

const API_BASE = 'http://localhost:8082/api';

export const getUsers = async () => {
  const res = await fetch(${API_BASE}/users, {
    // headers: {
    //   'Authorization': Bearer ${localStorage.getItem('token')}
    // }
  });
  if (!res.ok) {
    throw new Error('Не удалось загрузить пользователей');
  }
  const json = await res.json();
  return Array.isArray(json.users) ? json.users : json;  // ожидаем массив пользователей {id, name, email,...}
};

export const getRooms = async (userId) => {
  const res = await fetch(${API_BASE}/rooms/user-rooms/${userId}, {
    // headers: {
    //   'Authorization': Bearer ${localStorage.getItem('token')}
    // }
  });
  if (!res.ok) {
    throw new Error('Не удалось загрузить комнаты');
  }
  const json = await res.json();
  return Array.isArray(json.rooms) ? json.rooms : json; // ожидаем массив комнат {id, name, params, ...}
};

export const createRoom = async (userId, data) => {
  const res = await fetch(${API_BASE}/rooms/${userId}, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      // 'Authorization': Bearer ${localStorage.getItem('token')}
    },
    body: JSON.stringify(data) // data: { name, params: {...} }
  });
  if (!res.ok) {
    throw new Error('Не удалось создать комнату');
  }
  const json = await res.json();
  return Array.isArray(json.room) ? json.room : json; // ожидаем созданную комнату
};

const API_BASE = 'http://localhost:8082/api';

export const getSimulations = async (roomId) => {
  const res = await fetch(${API_BASE}/simulations/room-simulations/${roomId}, {
    // headers: {
    //   'Authorization': Bearer ${localStorage.getItem('token')}
    // }
  });
  if (!res.ok) {
    throw new Error('Не удалось загрузить список симуляций');
  }
  const json = await res.json();
  return Array.isArray(json.simulations) ? json.simulations : json; // ожидаем массив симуляций {id, controllerType, timestep, iterations, status, ...}
};

export const createSimulation = async (roomId, simData) => {
  const payload = { roomId, ...simData };
  const res = await fetch(http://localhost:8080/api/simulations/start, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      // 'Authorization': Bearer ${localStorage.getItem('token')}
    },
    body: JSON.stringify(payload)
    // simData включает: controllerType ('PID' или 'AI'), timestep, iterations, pidConfigId или modelId
  });
  if (!res.ok) {
    throw new Error('Не удалось создать симуляцию');
  }
  const json = await res.json();
  return Array.isArray(json.simulations) ? json.simulations : json;
};

// export const continueSimulation = async (simulationId) => {
//   const res = await fetch(${API_BASE}/simulations/${simulationId}/continue, {
//     method: 'POST',
//     // headers: {
//     //   'Authorization': Bearer ${localStorage.getItem('token')}
//     // }
//   });
//   if (!res.ok) {
//     throw new Error('Не удалось продолжить симуляцию');
//   }
//   const json = await res.json();
//   return Array.isArray(json.simulations) ? json.simulations : json;
// };

export const getSimulationDataPage = async (simId, page = 0, size = 1000) => {
  const res = await fetch(
    ${API_BASE}/sensor-data/simulation-data/${simId}?page=${page}&size=${size});
  if (!res.ok) throw new Error('Не удалось получить данные');
  const json = await res.json();
  // сервер может вернуть либо {data: [...]}, либо {sensorDataList: [...]}
  return (
    json.data ??
    json.sensorData ??
    json.sensorDataList ??
    []                // fallback: пустой массив
  );
};

export const getSimulationMetrics = async (simId) => {
  const res = await fetch(${API_BASE}/simulations/${simId}/metrics);
  if (!res.ok) throw new Error('Не удалось получить метрики');
  return await res.json();          // {mae, rmse, energyKWh, overshoot, …}
};


import React, { useState, useContext } from 'react';
import { useNavigate, Link } from 'react-router-dom';
import { useMutation } from '@tanstack/react-query';
import { AppContext } from '../context/AppContext';
import { login as loginApi } from '../api/auth';
import Card from '../ui/Card';
import Button from '../ui/Button';

const Login = () => {
  const { setUser } = useContext(AppContext);
  const navigate = useNavigate();
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');

  const { mutate: login, isLoading, error } = useMutation(loginApi, {
    onSuccess: (data) => {
      setUser(data);
      navigate('/dashboard');
    }
  });

  const handleSubmit = (e) => {
    e.preventDefault();
    login({ email, password });
  };

  return (
    <div className="flex justify-center items-center h-screen bg-gray-100">
      <Card className="w-full max-w-sm">
        <h2 className="text-xl font-semibold mb-4 text-center">Login</h2>
        <form onSubmit={handleSubmit} className="space-y-4">
          {error && <p className="text-red-500 text-sm">{error.message}</p>}
          <div>
            <label className="block text-sm font-medium mb-1">Email:</label>
            <input
              type="email"
              className="w-full border rounded px-3 py-2"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              required
            />
          </div>
          <div>
            <label className="block text-sm font-medium mb-1">Password:</label>
            <input
              type="password"
              className="w-full border rounded px-3 py-2"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              required
            />
          </div>
          <Button type="submit" disabled={isLoading} className="w-full">
            {isLoading ? 'Вход...' : 'Войти'}
          </Button>
        </form>
        <p className="mt-4 text-sm text-center">
          No account? <Link to="/register" className="text-blue-600 hover:underline">Sign up</Link>
        </p>
      </Card>
    </div>
  );
};

export default Login;

import React, { useState, useContext } from 'react';
import { useNavigate, Link } from 'react-router-dom';
import { useMutation } from '@tanstack/react-query';
import { AppContext } from '../context/AppContext';
import { register as registerApi } from '../api/auth';
import Card from '../ui/Card';
import Button from '../ui/Button';

const Register = () => {
  const { setUser } = useContext(AppContext);
  const navigate = useNavigate();
  const [username, setUsername] = useState('');
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');

  const { mutate: register, isLoading, error } = useMutation(registerApi, {
    onSuccess: (data) => {
      setUser(data.user);
      if (data.token) {
        localStorage.setItem('token', data.token);
      }
      navigate('/dashboard');
    }
  });

  const handleSubmit = (e) => {
    e.preventDefault();
    register({ username, email, password });
  };

  return (
    <div className="flex justify-center items-center h-screen bg-gray-100">
      <Card className="w-full max-w-sm">
        <h2 className="text-xl font-semibold mb-4 text-center">Registration</h2>
        <form onSubmit={handleSubmit} className="space-y-4">
          {error && <p className="text-red-500 text-sm">{error.message}</p>}
          <div>
            <label className="block text-sm font-medium mb-1">Username:</label>
            <input
              type="text"
              className="w-full border rounded px-3 py-2"
              value={username}
              onChange={(e) => setUsername(e.target.value)}
              required
            />
          </div>
          <div>
            <label className="block text-sm font-medium mb-1">Email:</label>
            <input
              type="email"
              className="w-full border rounded px-3 py-2"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              required
            />
          </div>
          <div>
            <label className="block text-sm font-medium mb-1">Password:</label>
            <input
              type="password"
              className="w-full border rounded px-3 py-2"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              required
            />
          </div>
          <Button type="submit" disabled={isLoading} className="w-full">
            {isLoading ? 'Registration...' : 'Register'}
          </Button>
        </form>
        <p className="mt-4 text-sm text-center">
          Have an account? <Link to="/login" className="text-blue-600 hover:underline">Login</Link>
        </p>
      </Card>
    </div>
  );
};

export default Register;

import React, { createContext, useState } from 'react';

export const AppContext = createContext(null);

export const AppContextProvider = ({ children }) => {
  const [user, setUser] = useState(null);
  const [room, setRoom] = useState(null);

  return (
    <AppContext.Provider value={{ user, setUser, room, setRoom }}>
      {children}
    </AppContext.Provider>
  );
};

import React, { useContext } from 'react';
import { AppContext } from '../context/AppContext';
import Button from '../ui/Button';

const Header = () => {
  const { user, setUser, setRoom } = useContext(AppContext);

  const handleLogout = () => {
    setUser(null);
    setRoom(null);
    localStorage.removeItem('token');
  };

  return (
    <header className="w-full flex justify-between items-center bg-white border-b px-4 py-2">
      <h1 className="text-xl font-semibold">Temperature Simulation System</h1>
      {user && (
        <div className="flex items-center space-x-4">
          <span className="text-gray-700">Hello, {user.name}!</span>
          <Button onClick={handleLogout}>Log out</Button>
        </div>
      )}
    </header>
  );
};

export default Header;

import React, { useContext } from 'react';
import { Outlet, Navigate } from 'react-router-dom';
import { AppContext } from '../context/AppContext';
import Header from './Header';
import Sidebar from './Sidebar';

const Layout = () => {
  const { user } = useContext(AppContext);

  if (!user) {
    return <Navigate to="/login" replace />;
  }

  return (
    <div className="h-screen flex flex-col">
      <Header />
      <div className="flex flex-1 overflow-hidden">
        <Sidebar />
        <main className="flex-1 p-4 overflow-auto">
          {}
          <Outlet />
        </main>
      </div>
    </div>
  );
};

export default Layout;

import React from 'react';
import { NavLink } from 'react-router-dom';

const Sidebar = () => {
  return (
    <aside className="bg-gray-800 text-white w-64 p-4">
      <nav className="space-y-2">
        <NavLink
          to="/dashboard"
          className={({ isActive }) =>
            block px-3 py-2 rounded ${isActive ? 'bg-gray-700 font-semibold' : 'hover:bg-gray-700'}
          }
        >
          Dashboard
        </NavLink>
        {}
      </nav>
    </aside>
  );
};

export default Sidebar;

import React, { useState, useContext } from 'react';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { AppContext }   from '../context/AppContext';
import { createLstmModel } from '../api/models';
import { getSimulations }  from '../api/simulations';
import Button              from '../ui/Button';

const LstmModelForm = () => {
  const { room }      = useContext(AppContext);
  const roomId        = room?.id;
  const queryClient   = useQueryClient();

  /* -------------------- локальний state форми -------------------- */
  const [form, setForm] = useState({
    simulationId  : '',
    HIDDEN_SIZE   : 128,
    NUM_LAYERS    : 2,
    SEQ_LENGTH    : 30,
    batch_size    : 64,
    epochs_number : 1,
  });
  const update = (key) => (e) => setForm({ ...form, [key]: e.target.value });

  /* -------------------- список симуляцій кімнати -------------------- */
  const { data: simulations = [] } = useQuery(
    ['simulations', roomId],
    () => getSimulations(roomId),
    { enabled: !!roomId }
  );

  /* -------------------- відправка на бекенд -------------------- */
  const { mutate: train, isLoading, error } = useMutation(
    () => createLstmModel({
      roomId,
      simulationId  : Number(form.simulationId),
      HIDDEN_SIZE   : Number(form.HIDDEN_SIZE),
      NUM_LAYERS    : Number(form.NUM_LAYERS),
      SEQ_LENGTH    : Number(form.SEQ_LENGTH),
      batch_size    : Number(form.batch_size),
      epochs_number : Number(form.epochs_number),
    }),
    {
      onSuccess: () => {
        queryClient.invalidateQueries(['models', roomId]);
        setForm({ ...form, simulationId: '' });          // повертаємо форму у початковий стан
      },
    }
  );

  const handleSubmit = (e) => {
    e.preventDefault();
    if (!room) return;
    train();
  };

  if (!room) return null;

  const labels = {
    HIDDEN_SIZE   : 'Hidden size (units)',
    NUM_LAYERS    : 'Number of layers',
    SEQ_LENGTH    : 'Sequence length',
    batch_size    : 'Batch size',
    epochs_number : 'Epochs',
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-3">
      <h3 className="font-semibold">Train new LSTM model</h3>

      {error && <p className="text-red-500 text-sm">{error.message}</p>}

      {/* ---------- вибір симуляції ---------- */}
      <label className="flex flex-col text-sm">
        <span className="mb-1 text-gray-700">Training simulation</span>
        <select
          className="w-full border rounded px-2 py-1"
          value={form.simulationId}
          onChange={update('simulationId')}
          required
        >
          <option value="">— choose simulation —</option>
          {simulations.map((s) => (
            <option key={s.id} value={s.id}>
              {s.controllerType} (id&nbsp;{s.id}, status&nbsp;{s.status})
            </option>
          ))}
        </select>
      </label>

      {/* ---------- гіперпараметри ---------- */}
      <div className="grid grid-cols-3 gap-2 sm:grid-cols-6">
        {Object.entries(labels).map(([key, lbl]) => (
          <label key={key} className="flex flex-col text-sm">
            <span className="mb-1 text-gray-700">{lbl}</span>
            <input
              className="w-full border rounded px-2 py-1"
              type="number"
              min="1"
              value={form[key]}
              onChange={update(key)}
              required
            />
          </label>
        ))}
      </div>

      <Button type="submit" disabled={isLoading}>
        {isLoading ? 'Training…' : 'Train LSTM'}
      </Button>
    </form>
  );
};

export default LstmModelForm;

import React, { useContext } from 'react';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { AppContext } from '../context/AppContext';
import { getModels, setModelActive } from '../api/models';
import Button from '../ui/Button';

const ModelList = () => {
  const { room } = useContext(AppContext);
  const qc       = useQueryClient();
  const roomId   = room?.id;

  /* ---------- fetch models ---------- */
  const { data: models = [], isLoading, isError, error } = useQuery(
    ['models', roomId],
    () => getModels(roomId),
    { enabled: !!roomId }
  );

  /* ---------- (не змінюємо) активація моделі ---------- */
  const { mutate: activateModel } = useMutation(
    ({ modelId }) => setModelActive(roomId, modelId),
    { onSuccess: () => qc.invalidateQueries(['models', roomId]) }
  );

  if (!room)        return null;
  if (isLoading)    return <p>Загрузка моделей…</p>;
  if (isError)      return <p className="text-red-500">Помилка: {error.message}</p>;

  return (
    <div>
      <h3 className="font-semibold mb-2">AI-моделі</h3>

      {models.length === 0 ? (
        <p>АІ-моделі відсутні.</p>
      ) : (
        <table className="w-full text-sm">
          <thead>
          <tr className="text-left border-b">
            <th className="py-1">Опис (description)</th>
            <th className="py-1">Тип</th>
            <th className="py-1"></th>
          </tr>
          </thead>
          <tbody>
          {models.map((m) => (
            <tr key={m.id} className="border-b last:border-b-0">
              <td className="py-1">{m.description}</td>
              <td className="py-1">{m.type}</td>
            </tr>
          ))}
          </tbody>
        </table>
      )}
    </div>
  );
};

export default ModelList;

import React, { useState, useContext } from 'react';
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { AppContext } from '../context/AppContext';
import { createRlModel } from '../api/models';
import Button from '../ui/Button';

const RlModelForm = () => {
  const { room } = useContext(AppContext);
  const qc       = useQueryClient();

  const [iterations,      setIterations]      = useState(100_000);
  const [timestepSeconds, setTimestepSeconds] = useState(60);
  const [lr,    setLr]    = useState(0.3);
  const [gamma, setGamma] = useState(0.99);
  const [eps,   setEps]   = useState(1.0);

  const { mutate: createModel, isLoading, error } = useMutation(
    () => createRlModel(room.id, { iterations, timestepSeconds, lr, gamma, eps}),
    {
      onSuccess: () => {
        qc.invalidateQueries(['models', room.id]);
        setIterations(100_000);
        setTimestepSeconds(60);
        setLr(0.3);
        setGamma(0.99);
        setEps(1.0);
      },
    }
  );

  const submit = (e) => {
    e.preventDefault();
    if (!room) return;
    createModel();
  };

  if (!room) return null;

  return (
    <form onSubmit={submit} className="space-y-4">
      <h3 className="font-semibold text-lg">Створити RL-модель</h3>

      {error && <p className="text-red-500 text-sm">{error.message}</p>}

      <div className="grid grid-cols-2 gap-3">

        <label className="flex flex-col text-sm">
          <span className="mb-0.5 text-gray-700">Iterations (steps)</span>
          <input
            type="number"
            min="1"
            placeholder="iterations"
            className="border rounded px-2 py-1"
            value={iterations}
            onChange={(e) => setIterations(Number(e.target.value))}
            required
          />
        </label>

        <label className="flex flex-col text-sm">
          <span className="mb-0.5 text-gray-700">Timestep, seconds</span>
          <input
            type="number"
            min="1"
            placeholder="timestep, s"
            className="border rounded px-2 py-1"
            value={timestepSeconds}
            onChange={(e) => setTimestepSeconds(Number(e.target.value))}
            required
          />
        </label>


        <label className="flex flex-col text-sm">
          <span className="mb-0.5 text-gray-700">LR (α)</span>
          <input
            type="number"
            step="0.001"
            min="0"
            max="1"
            className="border rounded px-2 py-1"
            value={lr}
            onChange={(e) => setLr(Number(e.target.value))}
            required
          />
        </label>

        <label className="flex flex-col text-sm">
          <span className="mb-0.5 text-gray-700">γ (discount)</span>
          <input
            type="number"
            step="0.001"
            min="0"
            max="1"
            className="border rounded px-2 py-1"
            value={gamma}
            onChange={(e) => setGamma(Number(e.target.value))}
            required
          />
        </label>

        {/* eps */}
        <label className="flex flex-col text-sm">
          <span className="mb-0.5 text-gray-700">ε (exploration)</span>
          <input
            type="number"
            step="0.001"
            min="0"
            max="1"
            className="border rounded px-2 py-1"
            value={eps}
            onChange={(e) => setEps(Number(e.target.value))}
            required
          />
        </label>

      </div>

      <Button type="submit" disabled={isLoading}>
        {isLoading ? 'Створення…' : 'Створити RL-модель'}
      </Button>
    </form>
  );
};

export default RlModelForm;

import React, { useState, useContext } from 'react';
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { AppContext } from '../context/AppContext';
import { createPIDConfig } from '../api/pid';
import Button from '../ui/Button';

const PIDForm = () => {
  const { room } = useContext(AppContext);
  const queryClient = useQueryClient();
  const [kp, setKp] = useState('');
  const [ki, setKi] = useState('');
  const [kd, setKd] = useState('');

  const { mutate: createPID, isLoading, error } = useMutation(
    (cfg) => createPIDConfig(room.id, cfg),
    {
      onSuccess: () => {
        queryClient.invalidateQueries(['pidConfigs', room.id]);
        setKp(''); setKi(''); setKd('');
      }
    }
  );

  const handleSubmit = (e) => {
    e.preventDefault();
    if (!room) return;
    createPID({ kp: parseFloat(kp), ki: parseFloat(ki), kd: parseFloat(kd), tunedMethod: 'Manual' });
  };

  if (!room) return null;

  return (
    <form onSubmit={handleSubmit}>
      <h3 className="font-semibold mb-2">Додати PID-конфігурацію вручну (Manual)</h3>
      {error && <p className="text-red-500 text-sm">{error.message}</p>}
      <div className="flex items-center space-x-2 mb-2">
        <input
          type="number" step="0.1" placeholder="Kp"
          className="border rounded px-2 py-1 w-20"
          value={kp} onChange={(e) => setKp(e.target.value)} required
        />
        <input
          type="number" step="0.1" placeholder="Ki"
          className="border rounded px-2 py-1 w-20"
          value={ki} onChange={(e) => setKi(e.target.value)} required
        />
        <input
          type="number" step="0.1" placeholder="Kd"
          className="border rounded px-2 py-1 w-20"
          value={kd} onChange={(e) => setKd(e.target.value)} required
        />
        <Button type="submit" disabled={isLoading}>
          {isLoading ? 'Збереження...' : 'Додати'}
        </Button>
      </div>
    </form>
  );
};

export default PIDForm;

// src/components/PIDList.jsx
import React, { useContext, useState }   from 'react';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { AppContext }  from '../context/AppContext';
import { getPIDConfigs, setPIDActive }   from '../api/pid';
import { autoTunePid }                   from '../api/pid';
import Button        from '../ui/Button';

const PIDList = () => {
  const { room } = useContext(AppContext);
  const qc       = useQueryClient();
  const roomId   = room?.id;

  /* ---- локальные поля формы автотюна ---- */
  const [iterations,      setIter]   = useState(60);
  const [timestepSeconds, setStep]   = useState(60);
  const [deltaPc, setDeltaPc] = useState(10);
  const [period, setPeriod] = useState(900);
  const [method,          setMethod] = useState('CohenCoon');

  const { data: configs = [], isLoading, isError, error } =
    useQuery(['pidConfigs', roomId], () => getPIDConfigs(roomId), { enabled: !!roomId });

  const { mutate: activatePID } = useMutation(
    ({ configId }) => setPIDActive(roomId, configId),
    { onSuccess: () => qc.invalidateQueries(['pidConfigs', roomId]) }
  );

  const { mutate: runTune, isLoading: isTuning } = useMutation(
    () => autoTunePid(roomId,
      { iterations: +iterations, timestepSeconds: +timestepSeconds, period: +period, deltaPc: +deltaPc, method }),
    { onSuccess: () => qc.invalidateQueries(['pidConfigs', roomId]) }
  );

  if (!room)                return null;
  if (isLoading)            return <p>Загрузка PID-конфігурацій…</p>;
  if (isError)              return <p className="text-red-500">Error: {error.message}</p>;

  return (
    <div>
      {}
      <div className="flex flex-wrap items-end gap-3 mb-2">

        <h3 className="font-semibold mr-auto">PID-конфігурації</h3>

        {}
        <div className="flex items-center space-x-2 text-sm">
          <label> Iter </label>
          <input  type="number" min="60"  value={iterations}
                  onChange={e=>setIter(e.target.value)}   className="w-20 border rounded px-1" />
          <label> dt, s </label>
          <input  type="number" min="60"   value={timestepSeconds}
                  onChange={e=>setStep(e.target.value)}   className="w-20 border rounded px-1" />
          <label> Delta pc </label>
          <input
            type="number"
            min="10"
            value={deltaPc}             // теперь правильно
            onChange={e => setDeltaPc(e.target.value)}
            className="w-20 border rounded px-1"
          />

          <label> Period, s </label>
          <input
            type="number"
            min="900"
            value={period}              // теперь правильно
            onChange={e => setPeriod(e.target.value)}
            className="w-20 border rounded px-1"
          />
          <select value={method} onChange={e=>setMethod(e.target.value)}
                  className="border rounded px-1">
            <option value="CohenCoon">Cohen-Coon</option>
            {/* будущие методы */}
          </select>
        </div>

        <Button onClick={runTune} disabled={isTuning}>
          {isTuning ? 'Тюнінг…' : 'Авто-тюнінг'}
        </Button>
      </div>

      {}
      {configs.length === 0 ? (
        <p>Конфігурації PID відсутні.</p>
      ) : (
        <table className="w-full text-sm">
          <thead>
          <tr className="text-left border-b">
            <th className="py-1">Kp</th><th>Ki</th><th>Kd</th>
          </tr>
          </thead>
          <tbody>
          {configs.map(cfg => (
            <tr key={cfg.id} className="border-b last:border-b-0">
              <td>{cfg.kp}</td><td>{cfg.ki}</td><td>{cfg.kd}</td>
              <td>{cfg.tunedMethod||'—'}</td>
            </tr>
          ))}
          </tbody>
        </table>
      )}
    </div>
  );
};

export default PIDList;

import React, { useContext, useState } from 'react';
import { AppContext } from '../context/AppContext';
import UserSelect from './UserSelect';
import RoomList from './RoomList';
import RoomForm from './RoomForm';
import Card from '../ui/Card';
import Tabs from '../ui/Tabs';
import PIDList from '../pid/PIDList';
import PIDForm from '../pid/PIDForm';
import ModelList from '../models/ModelList';
import LstmModelForm from '../models/LstmModelForm';
import RlModelForm from '../models/RlModelForm';
import SimulationList from '../simulations/SimulationList';
import SimulationForm from '../simulations/SimulationForm';

const Dashboard = () => {
  const { user, room } = useContext(AppContext);
  const [activeTab, setActiveTab] = useState('PID');  // по умолчанию первая вкладка

  const handleTabChange = (tab) => {
    setActiveTab(tab);
  };

  return (
    <div className="space-y-4">
      {}
      <Card>
        <UserSelect />
        {user ? (
          <>
            <RoomList />
            <RoomForm />
          </>
        ) : (
          <p className="text-gray-600">Оберіть користувача, щоб продивитись кімнати.</p>
        )}
      </Card>

      {}
      {room ? (
        <div>
          <Tabs
            tabs={['PID', 'AI-моделі', 'Симуляції']}
            activeTab={activeTab}
            onChange={handleTabChange}
          />
          <div className="mt-4">
            {activeTab === 'PID' && (
              <div className="space-y-4">
                <Card>
                  <PIDList />
                </Card>
                <Card>
                  <PIDForm />
                </Card>
              </div>
            )}
            {activeTab === 'AI-моделі' && (
              <div className="space-y-4">
                <Card>
                  <ModelList />
                </Card>
                <Card>
                  <LstmModelForm />
                </Card>
                <Card>
                  <RlModelForm />
                </Card>
              </div>
            )}
            {activeTab === 'Симуляції' && (
              <Card>
                <SimulationList />
              </Card>
            )}
          </div>
        </div>
      ) : (
        <p className="text-gray-600">Оберіть кімнату, щоб продивитись деталі (PID, моделі, симуляції).</p>
      )}
    </div>
  );
};

export default Dashboard;

import React, { useState, useContext } from 'react';
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { AppContext } from '../context/AppContext';
import { createRoom } from '../api/rooms';
import Button from '../ui/Button';

const RoomForm = () => {
  const { user } = useContext(AppContext);
  const queryClient = useQueryClient();
  const [name, setName] = useState('');
  const [roomParams, setRoomParams] = useState('{}');

  const { mutate: createRoomMutate, isLoading, error } = useMutation(
    ({ userId, data }) => createRoom(userId, data),
    {
      onSuccess: () => {
        queryClient.invalidateQueries(['rooms', user.id]);
        setName('');
        setRoomParams('{}');
      }
    }
  );

  const handleSubmit = (e) => {
    e.preventDefault();
    if (!user) return;
    let parsedRoomParams;
    try {
      parsedRoomParams = JSON.parse(roomParams);
    } catch {
      alert('Невірний JSON в параметрах кімнати');
      return;
    }
    createRoomMutate({ userId: user.id, data: { name, roomParams: parsedRoomParams } });
  };

  if (!user) return null;

  return (
    <form onSubmit={handleSubmit}>
      {error && <p className="text-red-500 text-sm mb-1">{error.message}</p>}
      <div className="flex items-center space-x-2 mb-2">
        <input
          type="text"
          placeholder="Назва кімнати"
          className="border rounded px-3 py-1 flex-1"
          value={name}
          onChange={(e) => setName(e.target.value)}
          required
        />
        <input
          type="text"
          placeholder="JSON параметри"
          className="border rounded px-3 py-1 flex-1"
          value={roomParams}
          onChange={(e) => setRoomParams(e.target.value)}
          required
        />
        <Button type="submit" disabled={isLoading}>
          {isLoading ? 'Створення...' : 'Додати кімнату'}
        </Button>
      </div>
    </form>
  );
};

export default RoomForm;

import React, { useContext } from 'react';
import { useQuery } from '@tanstack/react-query';
import { AppContext } from '../context/AppContext';
import { getRooms } from '../api/rooms';

const RoomList = () => {
  const { user, room, setRoom } = useContext(AppContext);

  const userId = user ? user.id : null;
  const { data: rooms, isLoading, isError, error } = useQuery(
    ['rooms', userId],
    () => getRooms(userId),
    { enabled: !!userId }
  );

  const handleSelectRoom = (roomItem) => {
    setRoom(roomItem);
  };

  if (!user) {
    return null;
  }
  if (isLoading) {
    return <p>Загрузка кімнат...</p>;
  }
  if (isError) {
    return <p className="text-red-500">Помилка загрузки кімнати: {error.message}</p>;
  }

  return (
    <div className="mb-4">
      <h3 className="font-semibold mb-2">Кімнати:</h3>
      {rooms.length === 0 ? (
        <p>Кімнати відсутні.</p>
      ) : (
        <ul className="space-y-1">
          {rooms.map(r => (
            <li
              key={r.id}
              className={cursor-pointer px-3 py-2 rounded ${room && r.id === room.id ? 'bg-blue-100' : 'hover:bg-gray-100'}}
              onClick={() => handleSelectRoom(r)}
            >
              {r.name}
            </li>
          ))}
        </ul>
      )}
    </div>
  );
};

export default RoomList;

import React, { useContext } from 'react';
import { useQuery } from '@tanstack/react-query';
import { AppContext } from '../context/AppContext';
import { getUsers } from '../api/rooms';

const UserSelect = () => {
  const { user, setUser, setRoom } = useContext(AppContext);

  // Получаем список всех пользователей (для админа)
  const { data: users, isLoading, isError, error } = useQuery(['users'], getUsers);

  const handleChange = (e) => {
    const userId = e.target.value;
    const selected = users.find(u => u.id === userId);
    setUser(selected || null);
    setRoom(null);
  };

  if (isLoading) {
    return <p>Загрузка списку користувачів...</p>;
  }
  if (isError) {
    return <p className="text-red-500">Помилка загрузки користувачів: {error.message}</p>;
  }

  return (
    <div className="mb-4">
      <label className="block text-sm font-medium mb-1">Користувач:</label>
      <select
        value={user ? user.id : ''}
        onChange={handleChange}
        className="border rounded px-3 py-2"
      >
        <option value="" disabled>Оберіть користувача...</option>
        {users.map(u => (
          <option key={u.id} value={u.id}>
            {u.name || u.email}
          </option>
        ))}
      </select>
    </div>
  );
};

export default UserSelect;

import React, { useState, useContext } from 'react';
import { useQuery }                 from '@tanstack/react-query';
import { AppContext }               from '../context/AppContext';
import { getPIDConfigs }            from '../api/pid';
import { getModels }                from '../api/models';
import Button                       from '../ui/Button';

const SimulationForm = ({ onCreate, onCancel }) => {
  const { room } = useContext(AppContext);

  const [controllerType, setControllerType] = useState('PID');
  const [pidConfigId,    setPidConfigId]    = useState('');
  const [modelId,        setModelId]        = useState('');
  const [timestepSeconds,setTimestepSeconds]= useState(60);
  const [iterations,     setIterations]     = useState(100);

  const { data: pidConfigs } = useQuery(
    ['pidConfigs', room?.id],
    () => getPIDConfigs(room.id),
    { enabled: !!room }
  );
  const { data: models } = useQuery(
    ['models', room?.id],
    () => getModels(room.id),
    { enabled: !!room }
  );

  const handleSubmit = (e) => {
    e.preventDefault();

    const data = {
      controllerType,
      timestepSeconds: Number(timestepSeconds),
      iterations:      Number(iterations)
    };

    if (controllerType === 'PID')      data.pidConfigId = Number(pidConfigId);
    if (controllerType === 'PID_LSTM') {
      data.pidConfigId = Number(pidConfigId);
      data.modelId     = Number(modelId);
    }
    if (controllerType === 'RL') data.modelId = Number(modelId);

    onCreate(data);
  };

  if (!room) return null;

  return (
    <form onSubmit={handleSubmit} className="border p-2 rounded bg-gray-50">
      <div className="grid grid-cols-2 gap-2 mb-2">

        {}
        <div>
          <label className="block text-sm">Тип контролера:</label>
          <select
            value={controllerType}
            onChange={(e) => setControllerType(e.target.value)}
            className="w-full border rounded px-2 py-1"
          >
            <option value="PID">PID</option>
            <option value="PID_LSTM">PID + LSTM</option>
            <option value="RL">RL-агент</option>
          </select>
        </div>

        {}
        <div>
          <label className="block text-sm">Шаг, сек:</label>
          <input
            type="number" min="1"
            className="w-full border rounded px-2 py-1"
            value={timestepSeconds}
            onChange={(e) => setTimestepSeconds(e.target.value)}
            required
          />
        </div>

        {}
        <div>
          <label className="block text-sm">Ітерації:</label>
          <input
            type="number" min="1"
            className="w-full border rounded px-2 py-1"
            value={iterations}
            onChange={(e) => setIterations(e.target.value)}
            required
          />
        </div>

        {}
        {(controllerType === 'PID' || controllerType === 'PID_LSTM') && (
          <div className="col-span-2">
            <label className="block text-sm">PID configuration:</label>
            <select
              value={pidConfigId}
              onChange={(e) => setPidConfigId(e.target.value)}
              className="w-full border rounded px-2 py-1"
              required
            >
              <option value="">Choose PID config…</option>
              {pidConfigs?.map(cfg => {
                const label = ${cfg.tunedMethod || 'Manual'} 
                  + (Kp=${cfg.kp ?? 0}, Ki=${cfg.ki ?? 0}, Kd=${cfg.kd ?? 0});
                return (
                  <option key={cfg.id} value={cfg.id} title={label}>
                    {label}
                  </option>
                );
              })}
            </select>
          </div>
        )}

        {}
        {(controllerType === 'PID_LSTM' || controllerType === 'RL') && (
          <div>
            <label className="block text-sm">AI-модель:</label>
            <select
              value={modelId}
              onChange={(e) => setModelId(e.target.value)}
              className="w-full border rounded px-2 py-1"
              required
            >
              <option value="">Оберіть модель</option>
              {models?.map((m) => {
                const modelLabel = ${m.id} (${m.type});
                return (
                  <option key={m.id} value={m.id} title={modelLabel}>
                    {modelLabel}
                  </option>
                );
              })}
            </select>
          </div>
        )}
      </div>

      {/* кнопки */}
      <div className="flex space-x-2">
        <Button type="submit">Запустити</Button>
      </div>
    </form>
  );
};

export default SimulationForm;

import React, { useMemo, useState, useEffect } from 'react';
import { useQuery } from '@tanstack/react-query';
import { ResizableBox } from 'react-resizable';
import {
  ResponsiveContainer,
  LineChart,
  Line,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  Legend,
} from 'recharts';
import { getSimulationDataPage, getSimulationMetrics } from '../api/simulations';
import Checkbox from '../ui/Checkbox';

const SimulationGraph = ({ simulation, onClose, page = 0, size = 0 }) => {
  const simId = simulation.id;
  const dashedFields = ['tempOut', 'predictedTemp'];

  const { data: rawData = [], isLoading, isError, error } = useQuery(
    ['simulationData', simId, page, size],
    () => getSimulationDataPage(simId, page, size),
    { enabled: !!simId }
  );

  const { data: metrics, isSuccess: metricsReady } = useQuery(
    ['metrics', simId],
    () => getSimulationMetrics(simId),
    { enabled: !!simId }
  );

  const { chartData, xKey } = useMemo(() => {
    let data = rawData;
    let xKey = 'iteration';
    if (data.length && data[0] && !data[0].hasOwnProperty(xKey)) {
      if (data[0].hasOwnProperty('time')) xKey = 'time';
      else {
        xKey = 'index';
        data = data.map((d, i) => ({ index: i, ...d }));
      }
    }
    return { chartData: data, xKey };
  }, [rawData]);

  const valueKeys = useMemo(() => {
    if (chartData.length === 0) return [];
    return Object.keys(chartData[0]).filter(
      (k) => k !== xKey && !['simulationId', 'timestamp', 'index'].includes(k)
    );
  }, [chartData, xKey]);

  const [selectedFields, setSelectedFields] = useState([]);
  useEffect(() => {
    if (selectedFields.length === 0 && valueKeys.length > 0) {
      setSelectedFields(valueKeys);
    }
  }, [selectedFields.length, valueKeys]);

  const isOnlyPower =
    selectedFields.length === 1 &&
    selectedFields[0].toLowerCase().includes('power');

  // Divide power values by 100 for display (e.g., 500 W -> 5)
  const processedData = useMemo(() => {
    if (chartData.length === 0) return [];
    const powerKeys = valueKeys.filter((k) => k.toLowerCase().includes('power'));
    return chartData.map((d) => {
      const entry = { ...d };
      powerKeys.forEach((pk) => {
        if (entry[pk] != null) {
          entry[pk] = entry[pk] / 100;
        }
      });
      return entry;
    });
  }, [chartData, valueKeys]);

  const xTicks = useMemo(() => {
    if (processedData.length === 0) return [];
    const vals = processedData.map((d) => d[xKey]);
    const min = Math.min(...vals);
    const max = Math.max(...vals);
    const hours = 60;
    const span = max - min;
    const step = Math.ceil(span / (5 * hours)) * hours || hours;
    const start = Math.ceil(min / hours) * hours;
    const ticks = [];
    for (let t = start; t <= max; t += step) ticks.push(t);
    return ticks;
  }, [processedData, xKey]);

  if (isLoading) return <p>Загрузка даних симуляції...</p>;
  if (isError)
    return (
      <div className="relative p-4 border">
        <p className="text-red-500">Помилка загрузки даних: {error.message}</p>
      </div>
    );
  if (!processedData.length)
    return (
      <div className="relative p-4 border">
        <p>Дані для відображення відсутні</p>
        <button onClick={onClose}>×</button>
      </div>
    );

  const handleToggleField = (field) => {
    setSelectedFields((prev) =>
      prev.includes(field) ? prev.filter((f) => f !== field) : [...prev, field]
    );
  };

  const colors = [
    '#000000', // чорний
    '#00008B', // темно-синій
    '#8B4513',  // коричневий
    '#2ca02c',
    '#700005',
    '#7f7f7f',
  ];

  return (
    <div className="relative mb-4 border rounded p-4 bg-white">
      <div className="text-center font-semibold mb-2">
        {isOnlyPower ? 'Heater Power (×0.01)' : 'Temperature'}
      </div>
      {metricsReady && (
        <table className="text-sm mb-2">
          <tbody>
          <tr>
            <td>MAE</td>
            <td>{metrics.mae.toFixed(2)} °C</td>
          </tr>
          <tr>
            <td>MSE</td>
            <td>{metrics.mse.toFixed(2)} °C</td>
          </tr>
          <tr>
            <td>RMSE</td>
            <td>{metrics.rmse.toFixed(2)} °C</td>
          </tr>
          <tr>
            <td>Енергія</td>
            <td>{metrics.energyKWh.toFixed(2)} кВт·год</td>
          </tr>
          <tr>
            <td>Перерегулювання</td>
            <td>{metrics.overshoot.toFixed(2)} °C</td>
          </tr>
          <tr>
            <td>Час врегулювання</td>
            <td>
              {metrics.settlingTimeS < 0
                ? '—'
                : metrics.settlingTimeS.toFixed(1) + ' с'}
            </td>
          </tr>
          </tbody>
        </table>
      )}
      <ResizableBox
        width={600}
        height={300}
        minConstraints={[300, 200]}
        maxConstraints={[1000, 600]}
      >
        <ResponsiveContainer width="100%" height="100%">
          <LineChart
            data={processedData}
            margin={{ top: isOnlyPower ? 20 : 40, right: 30, left: 20, bottom: 20 }}
          >
            <CartesianGrid stroke="#ccc" strokeDasharray="3 3" />
            <XAxis
              dataKey={xKey}
              ticks={xTicks}
              tickFormatter={(v) => ${Math.round(v / 1440)}}
              tickLine={false}
              label={{ value: 'Days', position: 'insideBottomRight', offset: -10 }}
            />
            <YAxis
              tickLine={false}
              label={{
                value: isOnlyPower ? 'Power (W/100)' : 'Temperature (°C)',
                angle: -90,
                position: 'insideLeft',
                offset: 0,
              }}
            />
            <Tooltip
              formatter={(value, name) => [
                name.toLowerCase().includes('power')
                  ? ${value.toFixed(2)}
                  : value,
                name,
              ]}
            />
            {isOnlyPower ? (
              <Legend layout="vertical" align="left" verticalAlign="middle" />
            ) : (
              <Legend verticalAlign="top" align="right" />
            )}
            {selectedFields.map((field, idx) => {
              const isDashed = field === 'tempOut';
              const isDashed2 = field === 'predictedTemp';
              return (
                <Line
                  key={field}
                  type="monotone"
                  dataKey={field}
                  stroke={colors[idx % colors.length]}
                  strokeWidth={2}
                  dot={false}
                  name={field}
                  // если поле есть в dashedFields — делаем штрихи 5px через 5px
                  strokeDasharray={isDashed ? '2 4' : undefined}
                  strokeDasharray2={isDashed2 ? '5 5' : undefined}
                />
              );
            })}
          </LineChart>
        </ResponsiveContainer>
      </ResizableBox>
      <div className="mt-2 flex flex-wrap items-center">
        {valueKeys.map((field) => (
          <Checkbox
            key={field}
            label={field}
            checked={selectedFields.includes(field)}
            onChange={() => handleToggleField(field)}
            className="mr-4 mb-1"
          />
        ))}
      </div>
    </div>
  );
};

export default SimulationGraph;

import React, { useContext, useState } from 'react';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { AppContext } from '../context/AppContext';
import { getSimulations, createSimulation } from '../api/simulations';
import SimulationForm   from './SimulationForm';
import SimulationGraph  from './SimulationGraph';
import Button           from '../ui/Button';
import RangeFilter      from '../ui/RangeFilter';

const SimulationList = () => {
  const { room }      = useContext(AppContext);
  const queryClient   = useQueryClient();

  const [showForm,     setShowForm]     = useState(false);
  const [openGraphIds, setOpenGraphIds] = useState([]);
  const [range,        setRange]        = useState({ page: 0, size: 0 });

  const roomId = room?.id ?? null;
  const { data: simulations = [], isLoading, isError, error } = useQuery(
    ['simulations', roomId],
    () => getSimulations(roomId),
    { enabled: !!roomId }
  );

  const { mutate: startSim } = useMutation(
    (simData) => createSimulation(roomId, simData),
    {
      onSuccess: () => {
        queryClient.invalidateQueries(['simulations', roomId]);
        setShowForm(false);
      }
    }
  );

  const handleOpenGraph  = (id) => !openGraphIds.includes(id) && setOpenGraphIds([...openGraphIds, id]);
  const handleCloseGraph = (id) => setOpenGraphIds(openGraphIds.filter(gid => gid !== id));

  if (!room)      return null;
  if (isLoading)  return <p>Загрузка симуляцій…</p>;
  if (isError)    return <p className="text-red-500">Помилка: {error.message}</p>;

  return (
    <div>
      <div className="flex justify-between items-center mb-2 space-x-4">
        <h3 className="font-semibold">Симуляції</h3>
        <Button onClick={() => setShowForm(!showForm)}>
          {showForm ? 'Відмінити' : 'Нова симуляція'}
        </Button>
      </div>

      {showForm && (
        <div className="mb-4">
          <SimulationForm onCreate={startSim} onCancel={() => setShowForm(false)} />
        </div>
      )}

      {simulations.length === 0 ? (
        <p>Симуляцій поки нема.</p>
      ) : (
        <table className="w-full text-sm mb-4">
          <thead>
          <tr className="text-left border-b">
            <th className="py-1">Тип контролера</th>
            <th className="py-1">Шаг</th>
            <th className="py-1">Ітерації</th>
            <th className="py-1">Статус</th>
            <th className="py-1">Дії</th>
          </tr>
          </thead>
          <tbody>
          {simulations.map(sim => (
            <tr key={sim.id} className="border-b last:border-b-0">
              <td className="py-1">{sim.controllerType}</td>
              <td className="py-1">{sim.timestepSeconds}</td>
              <td className="py-1">{sim.iterations}</td>
              <td className="py-1">{sim.status}</td>
              <td className="py-1">
                <Button size="sm" onClick={() => handleOpenGraph(sim.id)}>Графік</Button>
              </td>
            </tr>
          ))}
          </tbody>
        </table>
      )}

      {openGraphIds.length > 0 && (
        <div className="mb-3">
          <RangeFilter range={range} onChange={setRange} />
        </div>
      )}

      {openGraphIds.map(id => {
        const sim = simulations.find(s => s.id === id);
        return sim && (
          <SimulationGraph
            key={id}
            simulation={sim}
            page={range.page || 0}
            size={range.size || 0}
            onClose={() => handleCloseGraph(id)}
          />
        );
      })}
    </div>
  );
};

export default SimulationList;

import React from 'react';

const Button = ({ children, onClick, type = 'button', disabled = false, size = 'md', className = '' }) => {
  const baseStyle = 'inline-block text-white font-medium rounded focus:outline-none focus:ring';
  const colorStyle = disabled ? 'bg-blue-400 cursor-not-allowed' : 'bg-blue-600 hover:bg-blue-700';
  const sizeStyle = size === 'sm' ? 'px-2 py-1 text-sm' : 'px-4 py-2';
  return (
    <button
      type={type}
      onClick={onClick}
      disabled={disabled}
      className={${baseStyle} ${colorStyle} ${sizeStyle} ${className}}
    >
      {children}
    </button>
  );
};

export default Button;

import React from 'react';

const Card = ({ children, className = '' }) => {
  return (
    <div className={bg-white rounded shadow p-4 ${className}}>
      {children}
    </div>
  );
};

export default Card;

import React from 'react';

const Checkbox = ({ label, checked, onChange, className = '' }) => {
  return (
    <label className={inline-flex items-center ${className}}>
      <input
        type="checkbox"
        className="form-checkbox h-4 w-4 text-blue-600"
        checked={checked}
        onChange={onChange}
      />
      <span className="ml-2 text-sm">{label}</span>
    </label>
  );
};

export default Checkbox;

// RangeFilter.jsx
import React from 'react';

const RangeFilter = ({ range, onChange }) => (
  <div className="flex items-center space-x-1">
    <label className="text-sm">Page</label>
    <input
      type="number"
      value={range.page ?? ''}
      onChange={e => onChange({ ...range, page: Number(e.target.value) })}
      className="border rounded w-20 px-1 py-0.5 text-sm"
    />
    <label className="text-sm">Size</label>
    <input
      type="number"
      value={range.size ?? ''}
      onChange={e => onChange({ ...range, size: Number(e.target.value) })}
      className="border rounded w-20 px-1 py-0.5 text-sm"
    />
  </div>
);

export default RangeFilter;

import React from 'react';

const Tabs = ({ tabs, activeTab, onChange }) => {
  return (
    <div className="border-b flex space-x-4">
      {tabs.map(tab => (
        <button
          key={tab}
          onClick={() => onChange(tab)}
          className={py-2 px-3 -mb-px border-b-2 font-medium ${
            activeTab === tab ? 'border-blue-600 text-blue-600' : 'border-transparent text-gray-600'
          }}
        >
          {tab}
        </button>
      ))}
    </div>
  );
};

export default Tabs;

import React from 'react';
import { Routes, Route, Navigate } from 'react-router-dom';
import Layout from './layout/Layout';
import Login from './auth/Login';
import Register from './auth/Register';
import Dashboard from './rooms/Dashboard';

const App = () => {
  return (
    <Routes>
      {/* Маршруты без Layout (без авторизации) */}
      <Route path="/login" element={<Login />} />
      <Route path="/register" element={<Register />} />

      {/* Защищенные маршруты под главным Layout */}
      <Route path="/" element={<Layout />}>
        <Route path="dashboard" element={<Dashboard />} />
        <Route index element={<Navigate to="dashboard" />} />
      </Route>

      {/* 404 Not Found маршрут по желанию */}
      <Route path="*" element={<Navigate to="/dashboard" />} />
    </Routes>
  );
};

export default App;

package diplom.work.roomsimulatorservice.config;

import diplom.work.roomsimulatorservice.dto.storage.storage_sensor_client.SensorDataDTO;
import org.apache.kafka.clients.admin.NewTopic;
import org.apache.kafka.clients.producer.ProducerConfig;
import org.apache.kafka.common.serialization.StringSerializer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.kafka.annotation.EnableKafka;
import org.springframework.kafka.core.DefaultKafkaProducerFactory;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.kafka.core.ProducerFactory;
import org.springframework.kafka.support.serializer.JsonSerializer;

import java.util.HashMap;
import java.util.Map;

@Configuration
@EnableKafka
public class KafkaProducerConfig {

    @Bean
    public Map<String, Object> producerConfigs() {
        Map<String, Object> props = new HashMap<>();
        props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, "localhost:9092");
        props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class);
        props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, JsonSerializer.class);
        return props;
    }

    @Bean
    public ProducerFactory<String, SensorDataDTO> producerFactory() {
        return new DefaultKafkaProducerFactory<>(producerConfigs());
    }

    @Bean
    public KafkaTemplate<String, SensorDataDTO> kafkaTemplate() {
        return new KafkaTemplate<>(producerFactory());
    }

    @Bean
    public NewTopic sensorDataTopic() {
        return new NewTopic("simulation-data-topic", 3, (short) 1);
    }
}


package diplom.work.roomsimulatorservice.config;

import org.springframework.boot.context.properties.ConfigurationProperties;

@ConfigurationProperties("simulation.pid-lstm")
public record StrategyProperties(int predictionInterval, double correctionGain) {}


package diplom.work.roomsimulatorservice.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class WebConfig implements WebMvcConfigurer {
    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/api/**")
                .allowedOrigins("http://localhost:3000")
                .allowedMethods("GET","POST","PUT","DELETE","OPTIONS")
                .allowedHeaders("*")
                .allowCredentials(true);
    }
}


package diplom.work.roomsimulatorservice.controller;

import diplom.work.roomsimulatorservice.domain.SimulationContext;
import diplom.work.roomsimulatorservice.dto.RlTrainDTO.RlTrainDtoResponse;
import diplom.work.roomsimulatorservice.dto.RlTrainDTO.RlTrainSimulationDtoRequest;
import diplom.work.roomsimulatorservice.dto.SimulationRequestDTO;
import diplom.work.roomsimulatorservice.dto.SimulationResponseDTO;
import diplom.work.roomsimulatorservice.dto.SimulationStatusDTO;
import diplom.work.roomsimulatorservice.dto.autotunePidDTO.AutotunePidSimulationDtoRequest;
import diplom.work.roomsimulatorservice.service.simulations.SimulationRegistry;
import diplom.work.roomsimulatorservice.service.simulations.SimulationRunnerService;
import diplom.work.roomsimulatorservice.util.ControllerType;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/simulations")
@RequiredArgsConstructor
@Slf4j
public class SimulationController {

    private final SimulationRunnerService runnerService;
    private final SimulationRegistry registry;

    @PostMapping("/start")
    public ResponseEntity<SimulationResponseDTO> start(@RequestBody SimulationRequestDTO dto) {
        log.info(dto.controllerType().name());
        long simulationId = runnerService.startSimulation(dto);
        return ResponseEntity
                .accepted()
                .body(new SimulationResponseDTO(simulationId));
    }

    @PostMapping("/autotune/cohen-coon")
    public ResponseEntity<SimulationResponseDTO> autotune(@RequestBody AutotunePidSimulationDtoRequest dto) {
        long simulationId = runnerService.startSimulation(new SimulationRequestDTO(
                dto.roomId(), ControllerType.AUTOTUNE_PID, 0, 0, dto.iterations(), dto.timestepSeconds()
        ));
        return ResponseEntity
                .accepted()
                .body(new SimulationResponseDTO(simulationId));
    }

    @PostMapping("/train-rl")
    public ResponseEntity<SimulationResponseDTO> rlTrain(@RequestBody RlTrainSimulationDtoRequest dto) {
        long simulationId = runnerService.startSimulation(new SimulationRequestDTO(
                dto.roomId(), ControllerType.TRAIN_RL, 0, 0, dto.iterations(), dto.timestepSeconds()
        ));
        return ResponseEntity
                .accepted()
                .body(new SimulationResponseDTO(simulationId));
    }


    @GetMapping("/{id}/status")
    public ResponseEntity<SimulationStatusDTO> status(@PathVariable long id) {

        SimulationContext ctx = registry.get(id)
                .orElseThrow(() -> new IllegalArgumentException("Simulation " + id + " not found"));

        SimulationStatusDTO dto = new SimulationStatusDTO(
                id,
                ctx.isDone() ? "FINISHED" : "RUNNING",
                ctx.getProgress()
        );
        return ResponseEntity.ok(dto);
    }

    @GetMapping("/{id}/room-state")
    public ResponseEntity<?> roomState(@PathVariable long id) {

        SimulationContext ctx = registry.get(id)
                .orElseThrow(() -> new IllegalArgumentException("Simulation " + id + " not found"));

        return ResponseEntity.ok(ctx.getRoom().getRoomState());
    }
}


package diplom.work.roomsimulatorservice.domain.room;


import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import org.springframework.stereotype.Component;

import java.io.Serializable;

@Component
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class Room implements Serializable {
    private Long id;
    private String name;
    private RoomParams roomParams;
    private RoomState roomState;
}

package diplom.work.roomsimulatorservice.domain.room;


import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.Setter;

import java.io.Serializable;
import java.util.List;

@Getter
@Setter
@AllArgsConstructor
@Builder
public class RoomParams implements Serializable {

    private final double volume;
    private final List<SurfaceParams> surfaces;
    private final double airDensity;
    private final double airSpecificHeat;

    private final double airVolume;
    private final double airMass;
    private final double airHeatCapacity;

    @JsonCreator
    public RoomParams(
            @JsonProperty("volume")          double volume,
            @JsonProperty("airDensity")      double airDensity,
            @JsonProperty("airSpecificHeat") double airSpecificHeat,
            @JsonProperty("surfaces")        List<SurfaceParams> surfaces
    ) {
        this.volume          = volume;
        this.airDensity      = airDensity;
        this.airSpecificHeat = airSpecificHeat;
        this.surfaces        = surfaces;

        this.airVolume       = volume;
        this.airMass         = airDensity * volume;
        this.airHeatCapacity = airMass * airSpecificHeat;
    }
}


package diplom.work.roomsimulatorservice.domain.room;

import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.time.Instant;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Getter
@Setter
@NoArgsConstructor
public class RoomState {
    private double airTemperature = 20;
    private double outsideTemperature;
    private double setpointTemperature;
    private double predictedTemperature;

    private double heaterPower = 0;

    private final Map<String, Double> surfaceTemperatures = new HashMap<>();

    private boolean windowOpen = false;
    private boolean doorOpen = false;

    private int peopleCount = 0;

    private Instant lastUpdated = Instant.now();

    public RoomState(double initialAirTemp, List<SurfaceParams> surfaces) {
        this.airTemperature = initialAirTemp;

        for (SurfaceParams s : surfaces) {
            surfaceTemperatures.put(s.getName(), initialAirTemp-2);
        }
    }

    public double getSurfaceTemperature(String key) {
        return surfaceTemperatures.getOrDefault(key, 0.0);
    }

    /**
     * Обновить состояние через один шаг симуляции
     */
    public void update(
            double newAirTemp,
            double outsideTemperature,
            double newHeaterPower,
            Map<String, Double> newSurfaceTemps,
            boolean windowOpen,
            boolean doorOpen,
            int peopleCount
    ) {
        this.airTemperature = newAirTemp;
        this.outsideTemperature = outsideTemperature;
        this.heaterPower = newHeaterPower;
        this.windowOpen = windowOpen;
        this.doorOpen = doorOpen;
        this.peopleCount = peopleCount;
        this.lastUpdated = Instant.now();
        this.surfaceTemperatures.clear();
        this.surfaceTemperatures.putAll(newSurfaceTemps);
    }
}


package diplom.work.roomsimulatorservice.domain.room;

import com.fasterxml.jackson.annotation.JsonAlias;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Builder;
import lombok.Getter;
import lombok.ToString;

import java.io.Serializable;

@Getter
@ToString
public class SurfaceParams implements Serializable {
    private final String name;

    private final double area;          // A
    private final double thickness; // d
    private final double density; // p = m/V

    @JsonProperty("uInternal")
    private final double uInternal;     // U внутрішня
    @JsonProperty("uExternal")
    private final double uExternal;     // U зовнішня
    private final double thermalConductivity; // k_lambda // λ
    private final double specificHeat; // c
    private final double mass; // m = ρ · A · d
    private final double heatCapacity;  // C = c * m
    private final double totalU; // U // U = 1 / (1/Uвнутр + d/λ + 1/Uзовн)

    private final String adjacentRoomName;

    @JsonProperty("uInternal")
    public double getUInternal() { return uInternal; }

    @JsonProperty("uExternal")
    public double getUExternal() { return uExternal; }

    @JsonCreator
    @Builder
    public SurfaceParams(@JsonProperty("name") String name,
                         @JsonProperty("area") double area,
                         @JsonProperty("thickness") double thickness,
                         @JsonProperty("density") double density,
                         @JsonProperty("uInternal") @JsonAlias("uinternal") double uInternal,
                         @JsonProperty("uExternal") @JsonAlias("uexternal") double uExternal,
                         @JsonProperty("thermalConductivity") double thermalConductivity,
                         @JsonProperty("specificHeat") double specificHeat,
                         @JsonProperty("adjacentRoomName") String adjacentRoomName) {
        this.name = name;
        this.area = area;
        this.thickness = thickness;
        this.density = density;
        this.uInternal = uInternal;
        this.uExternal = uExternal;
        this.thermalConductivity = thermalConductivity;
        this.specificHeat = specificHeat;
        this.adjacentRoomName = adjacentRoomName;

        this.mass = density * area * thickness;
        this.heatCapacity = specificHeat * mass;
        this.totalU = 1.0 / (1.0 / uInternal + thickness / thermalConductivity + 1.0 / uExternal);
    }
}


package diplom.work.roomsimulatorservice.domain;

import lombok.Getter;

import java.time.Duration;
import java.time.LocalDateTime;

@Getter
public class SimulationClock {

    private LocalDateTime current;
    private final LocalDateTime start;
    private final Duration step;

    public SimulationClock(LocalDateTime startAt, Duration step) {
        this.current = startAt;
        this.step = step;
        this.start = startAt;
    }

    public LocalDateTime now() {
        return current;
    }

    public double dtSeconds() {
        return step.toSeconds();
    }

    public void tick() {
        current = current.plus(step);
    }
}


package diplom.work.roomsimulatorservice.domain;

import diplom.work.roomsimulatorservice.domain.room.Room;
import diplom.work.roomsimulatorservice.model.ThermalModel;
import diplom.work.roomsimulatorservice.service.strategies.SimulationStrategy;
import lombok.Builder;
import lombok.Getter;
import lombok.RequiredArgsConstructor;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Supplier;

@RequiredArgsConstructor
@Getter
@Builder
public class SimulationContext {

    private final Map<Object, Object> localStates = new ConcurrentHashMap<>();

    @SuppressWarnings("unchecked")
    public <T> T state(Object key, Supplier<T> init) {
        return (T) localStates.computeIfAbsent(key, k -> init.get());
    }

    public void putState(Object key, Object state) {
        localStates.put(key, state);
    }

    private final long   simulationId;
    private final int    configId;
    private final Long    modelId;

    private final Room               room;
    private final ThermalModel       thermalModel;
    private final SimulationStrategy strategy;
    private final SimulationClock    clock;

    private final long   iterations;
    private final double maxHeaterPower;

    public boolean isDone() {
        return clock.getStep().toSeconds() * iterations >=
                clock.now().getSecond() - clock.getStart().getSecond() ;
    }

    public double getProgress() {
        return 100.0 * (clock.getStep().toSeconds() * iterations) /
                (clock.now().getSecond() - clock.getStart().getSecond());
    }
}


package diplom.work.roomsimulatorservice.dto.autotunePidDTO;

public record AutotunePidDtoRequest(
        double roomTemp
) {
}


package diplom.work.roomsimulatorservice.dto.autotunePidDTO;

public record AutotunePidDtoResponse(
        double outputPower
) {
}


package diplom.work.roomsimulatorservice.dto.autotunePidDTO;

import diplom.work.roomsimulatorservice.util.ControllerType;

public record AutotunePidSimulationDtoRequest(
        long roomId,
        ControllerType controllerType,
        Long iterations,
        Integer timestepSeconds
) {
}


package diplom.work.roomsimulatorservice.dto.LstmModelDTO;

import java.util.List;

public record LstmModelDtoRequest (
        Long modelId,
        List<LstmSensorDTO> sensorDataDTOList
) {
}


package diplom.work.roomsimulatorservice.dto.LstmModelDTO;

public record LstmModelDtoResponse (
        double predictedTemp
) {
}


package diplom.work.roomsimulatorservice.dto.LstmModelDTO;

public record LstmSensorDTO(
        Double tempIn,
        Double tempOut,
        Double tempSetpoint,
        Double heaterPower
) {
}


package diplom.work.roomsimulatorservice.dto.PidDTO;

public record PIDRequest(
        Long simulationId,
        Integer pidConfigId,
        double targetTemperature,
        double currentTemperature,
        double deltaTime
) {}

package diplom.work.roomsimulatorservice.dto.PidDTO;

public record PIDResponse(
        double outputPower
) {}


package diplom.work.roomsimulatorservice.dto.RlModelDTO;

public record RlModelDtoRequest (
        Long modelId,
        double roomTemp,
        double outdoorTemp
){
}


package diplom.work.roomsimulatorservice.dto.RlModelDTO;

public record RlModelDtoResponse (
        double heaterPower
){
}


package diplom.work.roomsimulatorservice.dto.RlTrainDTO;

public record RlTrainDtoRequest(
        Long simulationId,
        double roomTemp,
        double outdoorTemp,
        double setpointTemp
) {
}


package diplom.work.roomsimulatorservice.dto.RlTrainDTO;

public record RlTrainDtoResponse(
        double heaterPower) {
}


package diplom.work.roomsimulatorservice.dto.RlTrainDTO;

import diplom.work.roomsimulatorservice.util.ControllerType;

public record RlTrainSimulationDtoRequest(
        long roomId,
        ControllerType controllerType,
        Long iterations,
        Integer timestepSeconds
) {
}


package diplom.work.roomsimulatorservice.dto;

import diplom.work.roomsimulatorservice.util.ControllerType;

public record SimulationRequestDTO(
    long roomId,
    ControllerType controllerType,
    Integer pidConfigId,
    Integer modelId,
    Long iterations,
    Integer timestepSeconds
//    List<SchedulePoint> schedule;
) {
}


package diplom.work.roomsimulatorservice.dto;

public record SimulationResponseDTO(
        Long simulationId
) {
}


package diplom.work.roomsimulatorservice.dto;

public record SimulationStatusDTO(long simulationId,
                                  String status,     // RUNNING | FINISHED | FAILED …
                                  double progress) {
}package diplom.work.roomsimulatorservice.dto;

public record SurfaceParamsDTO(
        String name,
        double area,
        double thickness,
        double density,
        double uInternal,
        double uExternal,
        double thermalConductivity,
        double specificHeat,
        String adjacentRoomName
) {
}


package diplom.work.roomsimulatorservice.feign.storage;

import diplom.work.roomsimulatorservice.dto.storage.storage_ai_client.AiModelDTO;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;

@FeignClient(name = "storage-ai-service", url = "${feign.client.config.storage-service.url}")
public interface StorageAiModelClient {

    @GetMapping("/api/models/{modelId}")
    ResponseEntity<AiModelDTO> getAiModelById(@PathVariable Integer modelId);
}


package diplom.work.roomsimulatorservice.feign.storage;

import diplom.work.roomsimulatorservice.dto.storage.storage_pid_client.PidConfigDTO;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;

@FeignClient(name = "storage-pid-service", url = "${feign.client.config.storage-service.url}")
public interface StoragePidConfigClient {

    @PostMapping("/api/pid-configs/room-configs/{roomId}")
    public ResponseEntity<PidConfigDTO> create(@PathVariable Long roomId,
                                               @RequestBody PidConfigDTO pidConfigDTO);

    @GetMapping("/api/pid-configs/{id}")
    ResponseEntity<PidConfigDTO> getConfigById(@PathVariable Integer id);
}


package diplom.work.roomsimulatorservice.feign.storage;

import diplom.work.roomsimulatorservice.dto.storage.storage_room_client.RoomDTO;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;

@FeignClient(name = "storage-room-service", url = "${feign.client.config.storage-service.url}")
public interface StorageRoomClient {

    @GetMapping("/api/rooms/{roomId}")
    ResponseEntity<RoomDTO> getRoomById(@PathVariable Long roomId);
}


package diplom.work.roomsimulatorservice.feign.storage;

import diplom.work.roomsimulatorservice.dto.storage.storage_sensor_client.SensorDataDTO;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;

import java.util.List;

@FeignClient(name = "storage-sensor-data-service", url = "${feign.client.config.storage-service.url}")
public interface StorageSensorDataClient {

    @PostMapping("/api/sensor-data/simulation-data/{simulationId}/step")
    ResponseEntity<SensorDataDTO> addStep(@PathVariable Long simulationId,
                                          @RequestBody SensorDataDTO sensorDataDTO);

    @PostMapping("/simulation-data/{simulationId}/batch")
    ResponseEntity<Void> addBatch(@PathVariable Long simulationId,
                                  @RequestBody List<SensorDataDTO> sensorDataDtoList);

    @GetMapping("/simulation-data/{simulationId}/last")
    ResponseEntity<SensorDataDTO> getLastBySimulationId(@PathVariable Long simulationId);


}


package diplom.work.roomsimulatorservice.feign.storage;

import diplom.work.roomsimulatorservice.dto.storage.storage_simulation_client.SimulationDTO;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@FeignClient(name = "storage-simulation-service", url = "${feign.client.config.storage-service.url}")
public interface StorageSimulationClient {

    @PostMapping("/api/simulations/{roomId}")
    public ResponseEntity<SimulationDTO> saveSimulation(@PathVariable Long roomId,
                                                        @RequestBody SimulationDTO simulationDTO);

    @GetMapping("/{id}")
    public ResponseEntity<SimulationDTO> getSimulationById(@PathVariable Long id);

    @PutMapping("/api/simulations/running/{id}")
    public ResponseEntity<SimulationDTO> markRunning(@PathVariable Long id);

    @PutMapping("/api/simulations/finished/{id}")
    public ResponseEntity<SimulationDTO> markFinished(@PathVariable Long id);

    @PutMapping("/api/simulations/failed/{id}")
    public ResponseEntity<SimulationDTO> markFailed(@PathVariable Long id);
}


package diplom.work.roomsimulatorservice.feign.storage;

import diplom.work.roomsimulatorservice.dto.storage.storage_user_client.UserResponseDTO;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;

@FeignClient(name = "storage-user-service", url = "${feign.client.config.storage-service.url}")
public interface StorageUserClient {

    @GetMapping("/api/users/email/{email}")
    ResponseEntity<UserResponseDTO> getUserByEmail(@PathVariable String email);
}


package diplom.work.roomsimulatorservice.feign;

import diplom.work.roomsimulatorservice.dto.LstmModelDTO.LstmModelDtoRequest;
import diplom.work.roomsimulatorservice.dto.LstmModelDTO.LstmModelDtoResponse;
import diplom.work.roomsimulatorservice.dto.RlModelDTO.RlModelDtoRequest;
import diplom.work.roomsimulatorservice.dto.RlModelDTO.RlModelDtoResponse;
import diplom.work.roomsimulatorservice.dto.autotunePidDTO.AutotunePidDtoRequest;
import diplom.work.roomsimulatorservice.dto.autotunePidDTO.AutotunePidDtoResponse;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestBody;

@FeignClient(name = "AI-models", url = "${feign.client.config.AI-models.url}")
public interface AiModelsClient {

    @GetMapping("/lstm/predict")
    LstmModelDtoResponse predictTemperatureLSTM(@RequestBody LstmModelDtoRequest request);

    @GetMapping("/rl/compute")
    RlModelDtoResponse computeHeatRL(@RequestBody RlModelDtoRequest request);
}


package diplom.work.roomsimulatorservice.feign;

import diplom.work.roomsimulatorservice.dto.autotunePidDTO.AutotunePidDtoRequest;
import diplom.work.roomsimulatorservice.dto.autotunePidDTO.AutotunePidDtoResponse;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;

@FeignClient(name = "pid-autotuner", url = "${feign.client.config.pid-autotuner.url}")
public interface AutotuneClient {

    @PostMapping("/api/power/{simulationId}")
    AutotunePidDtoResponse compute(@PathVariable Long simulationId,
                                   @RequestBody AutotunePidDtoRequest request);
}


package diplom.work.roomsimulatorservice.feign;

import diplom.work.roomsimulatorservice.dto.PidDTO.PIDRequest;
import diplom.work.roomsimulatorservice.dto.PidDTO.PIDResponse;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;

@FeignClient(name = "pid-controller", url = "${feign.client.config.pid-controller.url}")
public interface PIDClient {

    @PostMapping("/api/pid/compute")
    PIDResponse compute(@RequestBody PIDRequest request);
}


package diplom.work.roomsimulatorservice.feign;

import diplom.work.roomsimulatorservice.dto.RlTrainDTO.RlTrainDtoRequest;
import diplom.work.roomsimulatorservice.dto.RlTrainDTO.RlTrainDtoResponse;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;

@FeignClient(name = "rl-trainer", url = "${feign.client.config.RL-trainer.url}")
public interface RlTrainClient {

    @PostMapping("/compute")
    RlTrainDtoResponse compute(@RequestBody RlTrainDtoRequest request);
}


package diplom.work.roomsimulatorservice.model;

import diplom.work.roomsimulatorservice.domain.SimulationContext;
import diplom.work.roomsimulatorservice.domain.room.Room;
import diplom.work.roomsimulatorservice.domain.room.RoomParams;
import diplom.work.roomsimulatorservice.domain.room.RoomState;
import diplom.work.roomsimulatorservice.service.calculations.OutsideTempCalculation;
import diplom.work.roomsimulatorservice.service.calculations.PeopleHeatCalculation;
import diplom.work.roomsimulatorservice.service.calculations.PhysicsCalculation;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

import java.util.Map;
import java.util.Optional;
import java.util.Queue;

@Component("thermalModel1")
@RequiredArgsConstructor
@Slf4j
public class AdvancedThermalModel implements ThermalModel {

    private final PhysicsCalculation physicsCalculation;
    private final OutsideTempCalculation outsideTempCalculation;
    private final PeopleHeatCalculation peopleHeatCalculation;

    @Override
    public void applyStep(SimulationContext ctx, double heaterPower) {
        Room room = ctx.getRoom();
        RoomParams roomParams = room.getRoomParams();
        RoomState roomState = room.getRoomState();

        Queue<Double> extQueue = ctx.state("OUT_TEMP_QUEUE", () ->
                outsideTempCalculation.computeOutsideTemperature(2024)
        );

        Optional<Double> tOutOpt = Optional.ofNullable(extQueue.poll());
        if (!tOutOpt.isPresent()) {
            ctx.putState("OUT_TEMP_QUEUE", outsideTempCalculation.computeOutsideTemperature(2024));
            tOutOpt = Optional.ofNullable(((Queue<Double>) ctx.state("OUT_TEMP_QUEUE", () -> null)).poll());
        }
        double outsideTemp = tOutOpt.orElse(roomState.getOutsideTemperature());

        double heaterMaxPower = ctx.getMaxHeaterPower();
        double heaterPowerWatts = Math.min(heaterMaxPower,
                Math.max(100, heaterMaxPower * (heaterPower / 100.0)));

        double totalHeatFlow = physicsCalculation.computeSurfaceHeatFlow(roomParams, roomState);

        double peopleHeatFlow = peopleHeatCalculation.computePeopleHeat(roomState.getPeopleCount());

        // Общий поток
        double totalQ = totalHeatFlow + heaterPowerWatts + peopleHeatFlow;

        // Изменение температуры воздуха
        double dT_air = totalQ / roomParams.getAirHeatCapacity();
        double newAirTemp = roomState.getAirTemperature() +
                dT_air * ctx.getClock().getStep().toSeconds();

        Map<String, Double> newSurfaceTemps = physicsCalculation.computeNewSurfacesTemps(
                roomParams,
                roomState,
                roomState.getOutsideTemperature(),
                ctx.getClock().getStep().toSeconds());

        log.info("[SIM:{}] t={}, step={}s, heaterPowerPct={}%, heaterPowerWatt={}, " +
                        "T_air(prev)={}, T_air(new)={}, T_setpoint={}, T_out={}, " +
                        "totalHeatFlowW={}, totalQ_W={}, surfaces={} ",
                ctx.getSimulationId(),
                ctx.getClock().now(),
                ctx.getClock().getStep().toSeconds(),
                heaterMaxPower,
                heaterPowerWatts,
                roomState.getAirTemperature(),
                newAirTemp,
                roomState.getSetpointTemperature(),
                outsideTemp,
                totalHeatFlow,
                totalQ,
                newSurfaceTemps);

        roomState.update(
                newAirTemp,
                outsideTemp,
                heaterPowerWatts,
                newSurfaceTemps,
                false,
                false,
                0
        );
    }
}


package diplom.work.roomsimulatorservice.model;

import diplom.work.roomsimulatorservice.domain.SimulationContext;
import diplom.work.roomsimulatorservice.domain.room.Room;
import diplom.work.roomsimulatorservice.domain.room.RoomParams;
import diplom.work.roomsimulatorservice.domain.room.RoomState;
import diplom.work.roomsimulatorservice.service.calculations.OutsideTempCalculation;
import diplom.work.roomsimulatorservice.service.calculations.PhysicsCalculation;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

import java.util.Map;
import java.util.Optional;
import java.util.Queue;

@Component("thermalModel0")
@RequiredArgsConstructor
@Slf4j
public class SimpleThermalModel implements ThermalModel {

    private final PhysicsCalculation physicsCalculation;
    private final OutsideTempCalculation outsideTempCalculation;

    @Override
    public void applyStep(SimulationContext ctx, double heaterPower) {
        Room room = ctx.getRoom();
        RoomParams roomParams = room.getRoomParams();
        RoomState roomState = room.getRoomState();

        Queue<Double> extQueue = ctx.state("OUT_TEMP_QUEUE", () ->
                outsideTempCalculation.computeOutsideTemperature(2023)
        );

        Optional<Double> tOutOpt = Optional.ofNullable(extQueue.poll());
        if (!tOutOpt.isPresent()) {
            ctx.putState("OUT_TEMP_QUEUE", outsideTempCalculation.computeOutsideTemperature(2023));
            tOutOpt = Optional.ofNullable(((Queue<Double>) ctx.state("OUT_TEMP_QUEUE", () -> null)).poll());
        }
        double outsideTemp = tOutOpt.orElse(roomState.getOutsideTemperature());

        double heaterMaxPower = ctx.getMaxHeaterPower();
        double heaterPowerWatts = Math.min(heaterMaxPower,
                Math.max(0, heaterMaxPower * (heaterPower / 100.0)));
        log.info("Heater Power: " + heaterPowerWatts);

        double totalHeatFlow = physicsCalculation.computeSurfaceHeatFlow(roomParams, roomState);
        log.info("Total Flow: " + totalHeatFlow);

        // Общий поток
        double totalQ = totalHeatFlow + heaterPowerWatts;
        log.info("Total Q: " + totalQ);

        // Изменение температуры воздуха
        double dT_air = totalQ / roomParams.getAirHeatCapacity();
        double newAirTemp = roomState.getAirTemperature() +
                dT_air * ctx.getClock().getStep().toSeconds();

        Map<String, Double> newSurfaceTemps = physicsCalculation.computeNewSurfacesTemps(
                roomParams,
                roomState,
                roomState.getOutsideTemperature(),
                ctx.getClock().getStep().toSeconds());

        log.info("[SIM:{}] t={}, step={}s, heaterMaxPower={}, heaterPowerWatts={}, T_air(prev)={}, T_air(new)={}, T_setpoint={}, T_out={}, totalHeatFlowW={}, totalQ_W={}, surfaces={} ",
                ctx.getSimulationId(),
                ctx.getClock().now(),
                ctx.getClock().getStep().toSeconds(),
                heaterMaxPower,
                heaterPowerWatts,
                roomState.getAirTemperature(),
                newAirTemp,
                roomState.getSetpointTemperature(),
                outsideTemp,
                totalHeatFlow,
                totalQ,
                newSurfaceTemps);

        roomState.update(
                newAirTemp,
                outsideTemp,
                heaterPowerWatts,
                newSurfaceTemps,
                false,
                false,
                0
        );
    }
}


package diplom.work.roomsimulatorservice.model;

import diplom.work.roomsimulatorservice.domain.SimulationContext;

public interface ThermalModel {
    void applyStep(SimulationContext simulationContext, double heaterPower);
}


package diplom.work.roomsimulatorservice.service.calculations;

import diplom.work.roomsimulatorservice.domain.room.SurfaceParams;

public class OpenDoorCalculation {

    public SurfaceParams createOpenSurface(SurfaceParams original) {
        return SurfaceParams.builder()
                .name(original.getName())
                .area(original.getArea())
                .thickness(0.001) // почти ноль
                .density(1.293) // воздух
                .thermalConductivity(0.025) // воздух
                .uInternal(1000.0)
                .uExternal(1000.0)
                .specificHeat(1005.4)
                .adjacentRoomName(original.getAdjacentRoomName())
                .build();
    }
}


package diplom.work.roomsimulatorservice.service.calculations;

import diplom.work.roomsimulatorservice.domain.room.SurfaceParams;

public class OpenWindowCalculation {

    public SurfaceParams createOpenSurface(SurfaceParams original) {
        return SurfaceParams.builder()
                .name(original.getName())
                .area(original.getArea())
                .thickness(0.001) // почти ноль
                .density(1.293) // воздух
                .thermalConductivity(0.025) // воздух
                .uInternal(1000.0)
                .uExternal(1000.0)
                .specificHeat(1005.4)
                .adjacentRoomName(original.getAdjacentRoomName())
                .build();
    }
}


package diplom.work.roomsimulatorservice.service.calculations;

import diplom.work.roomsimulatorservice.util.TemperatureLoader;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.List;
import java.util.Queue;

@Component
public class OutsideTempCalculation {

    public Queue<Double> computeOutsideTemperature(Integer year) {
        Path path;
        Path path2;
        Path path3;

        List<Double> allTemps = new ArrayList<>();
        try {
            if (year == 2023) {
                path = Path.of("src", "main", "resources", "response3.csv");
                path2 = Path.of("src", "main", "resources", "response5.csv");
                allTemps.addAll(TemperatureLoader.readTempsFromCsv(path));
                allTemps.addAll(TemperatureLoader.readTempsFromCsv(path2));
            } else {
                path = Path.of("src", "main", "resources", "response.csv");
                path2 = Path.of("src", "main", "resources", "response2.csv");
                path3 = Path.of("src", "main", "resources", "response4.csv");
                allTemps.addAll(TemperatureLoader.readTempsFromCsv(path));
                allTemps.addAll(TemperatureLoader.readTempsFromCsv(path2));
                allTemps.addAll(TemperatureLoader.readTempsFromCsv(path3));
            }
        } catch (IOException e) {
            throw new RuntimeException(e);
        }

        return TemperatureLoader.upsampleToOneMinute(allTemps);
    }
}


package diplom.work.roomsimulatorservice.service.calculations;

import org.springframework.stereotype.Component;

@Component
public class PeopleHeatCalculation {

    public double computePeopleHeat(int peopleCount) {
        return peopleCount * 100.0;
    }
}


package diplom.work.roomsimulatorservice.service.calculations;

import diplom.work.roomsimulatorservice.domain.room.RoomParams;
import diplom.work.roomsimulatorservice.domain.room.RoomState;
import diplom.work.roomsimulatorservice.domain.room.SurfaceParams;
import org.springframework.stereotype.Service;

import java.util.HashMap;
import java.util.Map;

@Service
public class PhysicsCalculation {

    public Map<String, Double> computeNewSurfacesTemps(RoomParams roomParams, RoomState roomState, double outsideTemperature, double dt) {
        Map<String, Double> newSurfaceTemps = new HashMap<>();
        double roomTemp = roomState.getAirTemperature();

        for (SurfaceParams surface : roomParams.getSurfaces()) {
            String surfaceName = surface.getName();
            double surfaceTemp = roomState.getSurfaceTemperature(surfaceName);

            double adjacentTemp;

            if (surface.getAdjacentRoomName() == null) {
                adjacentTemp = outsideTemperature;
            } else {
                adjacentTemp = 20.0;
            }

            double dT_surface = computeSurfaceTemperatureChange(surface, roomTemp, surfaceTemp, adjacentTemp);
            surfaceTemp += dT_surface * dt;

            newSurfaceTemps.put(surfaceName, surfaceTemp);
        }
        return newSurfaceTemps;
    }

    private double computeSurfaceTemperatureChange(SurfaceParams s,
                                                   double airT, double wallT,
                                                   double outT) {

        double hInt = s.getUInternal();
        double uTotal = calcU(s);

        double area = s.getArea();
        double qIn  = hInt  * area * (airT  - wallT);
        double qOut = uTotal * area * (wallT - outT);

        return (qIn - qOut) / s.getHeatCapacity();
    }

    public double computeSurfaceHeatFlow(RoomParams roomParams, RoomState roomState) {

        double qTotal = 0;
        double airT = roomState.getAirTemperature();

        for (SurfaceParams s : roomParams.getSurfaces()) {
            String name = s.getName();
            double surfaceTemp = roomState.getSurfaceTemperature(name);

            double qConvInt = s.getUInternal() * s.getArea() * (airT - surfaceTemp);
            qTotal -= qConvInt;
        }
        return qTotal;   // Вт
    }

    private double calcU(SurfaceParams s) {
        double hInt = s.getUInternal();          // 8  Вт/(м²·К)
        double hExt = s.getUExternal();          // 25 Вт/(м²·К)
        double rCond = s.getThickness() / s.getThermalConductivity(); // L/λ
        double rTotal = (1.0 / hInt) + rCond + (1.0 / hExt);
        return 1.0 / rTotal;                     // Вт/(м²·К)
    }
}


package diplom.work.roomsimulatorservice.service.calculations;

import org.springframework.stereotype.Component;

import java.time.LocalDateTime;

@Component
public class TargetTemperatureCalculation {

    public double getTargetTemperature(LocalDateTime timestamp) {
        int hour = timestamp.getHour();

        if (hour < 4) {
            return 20.0;
        } else if (hour < 12) {
            return 19.0;
        } else {
            return 23.0;
        }
    }
}


package diplom.work.roomsimulatorservice.service.simulations;

import diplom.work.roomsimulatorservice.domain.SimulationContext;
import diplom.work.roomsimulatorservice.domain.room.RoomState;
import diplom.work.roomsimulatorservice.dto.storage.storage_sensor_client.SensorDataDTO;
import diplom.work.roomsimulatorservice.feign.storage.StorageSimulationClient;
import diplom.work.roomsimulatorservice.service.KafkaSensorProducer;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Component;

@Component
@RequiredArgsConstructor
@Slf4j
public class SimulationEngine {

    private final KafkaSensorProducer producer;       // публикуем результаты
    private final StorageSimulationClient storageSimulationClient;        // меняем статус SIMULATION → FINISHED

    /**
     * Основной цикл. Вызов НЕ блокирует HTTP-поток: сервис-оркестратор
     * отправляет его в @Async или в TaskExecutor.
     */
    @Async
    public void run(SimulationContext ctx) {
        try {
            storageSimulationClient.markRunning(ctx.getSimulationId());
            for (long step = 0; step < ctx.getIterations(); step++) {

                // 1) стратегия выдаёт мощность нагревателя
                double heaterPower = ctx.getStrategy().compute(ctx);
                log.info("Heater power: " + heaterPower);
                // 2) тепловая модель считает ∆T помещения
                ctx.getThermalModel().applyStep(ctx, heaterPower);

                RoomState state = ctx.getRoom().getRoomState();
                SensorDataDTO sensorDataDTO = new SensorDataDTO(
                        ctx.getSimulationId(),
                        ctx.getClock().now(),
                        state.getAirTemperature(),
                        state.getOutsideTemperature(),
                        state.getSetpointTemperature(),
                        state.getHeaterPower(),
                        state.getPredictedTemperature(),
                        state.isWindowOpen(),
                        state.isDoorOpen(),
                        state.getPeopleCount()
                );

                // 3) публикуем результаты в Kafka
                producer.sendSensorData(
                        sensorDataDTO
                );

                // 4) тикаем симуляционные часы
                ctx.getClock().tick();
            }

            storageSimulationClient.markFinished(ctx.getSimulationId());

        } catch (Exception ex) {
            storageSimulationClient.markFailed(ctx.getSimulationId());
            throw ex;
        }
    }
}


package diplom.work.roomsimulatorservice.service.simulations;

import diplom.work.roomsimulatorservice.domain.SimulationContext;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;

import java.util.Map;
import java.util.Optional;
import java.util.concurrent.ConcurrentHashMap;

@Service
public class SimulationRegistry {

    private final Map<Long, SimulationContext> running = new ConcurrentHashMap<>();

    public void put(SimulationContext ctx) {
        running.put(ctx.getSimulationId(), ctx);
    }

    public Optional<SimulationContext> get(long id) {
        return Optional.ofNullable(running.get(id));
    }

    @Scheduled(fixedRate = 60000)
    public void remove() {
        for (SimulationContext ctx : running.values()) {
            if (ctx.isDone()) {
                running.remove(ctx.getSimulationId());
            }
        }
    }
}


package diplom.work.roomsimulatorservice.service.simulations;

import diplom.work.roomsimulatorservice.domain.SimulationClock;
import diplom.work.roomsimulatorservice.domain.SimulationContext;
import diplom.work.roomsimulatorservice.domain.room.Room;
import diplom.work.roomsimulatorservice.domain.room.RoomState;
import diplom.work.roomsimulatorservice.dto.SimulationRequestDTO;
import diplom.work.roomsimulatorservice.dto.storage.storage_ai_client.AiModelDTO;
import diplom.work.roomsimulatorservice.dto.storage.storage_pid_client.PidConfigDTO;
import diplom.work.roomsimulatorservice.dto.storage.storage_room_client.RoomDTO;
import diplom.work.roomsimulatorservice.dto.storage.storage_simulation_client.SimulationDTO;
import diplom.work.roomsimulatorservice.feign.storage.StorageAiModelClient;
import diplom.work.roomsimulatorservice.feign.storage.StoragePidConfigClient;
import diplom.work.roomsimulatorservice.feign.storage.StorageRoomClient;
import diplom.work.roomsimulatorservice.feign.storage.StorageSimulationClient;
import diplom.work.roomsimulatorservice.model.SimpleThermalModel;
import diplom.work.roomsimulatorservice.service.strategies.StrategyRegistry;
import diplom.work.roomsimulatorservice.service.strategies.TrainRlSimulationStrategy;
import diplom.work.roomsimulatorservice.util.ControllerType;
import diplom.work.roomsimulatorservice.util.RoomMapper;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.time.Duration;
import java.time.LocalDateTime;
import java.time.temporal.ChronoUnit;
import java.util.Objects;

@Slf4j
@Service
@RequiredArgsConstructor
public class SimulationRunnerService {

    private final StorageRoomClient roomClient;
    private final StoragePidConfigClient pidClient;
    private final StorageSimulationClient simulationClient;
    private final StorageAiModelClient aiModelClient;

    private final SimpleThermalModel simpleThermalModel;
    private final StrategyRegistry strategyRegistry;
    private final SimulationRegistry simulationRegistry;
    private final SimulationEngine engine;

    private final RoomMapper roomMapper;

    public Long startSimulation(SimulationRequestDTO dto) {

        /*────────────────── 0. Валидация и загрузка комнаты ──────────────────*/
        Long roomId = dto.roomId();
        RoomDTO roomDto = roomClient.getRoomById(roomId).getBody();
        if (roomDto == null)
            throw new IllegalStateException("Room " + roomId + " not found");
        Room room = roomMapper.toEntity(roomDto);

        /*────────────────── 1. Загрузка PID-конфига / AI-модели ───────────────*/
        PidConfigDTO pidCfg = null;
        AiModelDTO   aiCfg  = null;

        ControllerType type = dto.controllerType();

        switch (type) {
            case PID -> {
                Integer cfgId = Objects.requireNonNull(dto.pidConfigId(),
                        "pidConfigId required for PID");
                pidCfg = pidClient.getConfigById(cfgId).getBody();
            }
            case PID_LSTM -> {
                Integer cfgId   = Objects.requireNonNull(dto.pidConfigId(),
                        "pidConfigId required for PID_LSTM");
                Integer modelId = Objects.requireNonNull(dto.modelId(),
                        "modelId required for PID_LSTM");
                pidCfg = pidClient.getConfigById(cfgId).getBody();
                aiCfg  = aiModelClient.getAiModelById(modelId).getBody();
            }
            case RL -> {
                Integer modelId = Objects.requireNonNull(dto.modelId(),
                        "modelId required for RL controller");
                aiCfg = aiModelClient.getAiModelById(modelId).getBody();
            }
            case TRAIN_RL -> 
            {

            }
            case AUTOTUNE_PID ->
            {

            }
            default -> throw new IllegalArgumentException("Unsupported controller: " + type);
        }

        /*────────────────── 2. Clock и начальное состояние комнаты ────────────*/
        double INITIAL_AIR_TEMP = 20.0;
        double MAX_HEATER_POWER = 3000.0;
        LocalDateTime START_TS  = LocalDateTime.of(2023, 9, 1, 0, 0);

        room.setRoomState(new RoomState(
                INITIAL_AIR_TEMP,
                room.getRoomParams().getSurfaces())
        );

        SimulationClock clock = new SimulationClock(
                START_TS,
                Duration.of(dto.timestepSeconds() != null ? dto.timestepSeconds() : 60, ChronoUnit.SECONDS)
        );

        /*────────────────── 3. Создаём запись Simulation в storage ────────────*/
        SimulationDTO simDto = new SimulationDTO(
                roomId,
                type,
                "CREATED",
                dto.iterations(),
                dto.timestepSeconds()
        );
        Long simId = simulationClient.saveSimulation(roomId, simDto).getBody().id();

        /*────────────────── 4. Собираем SimulationContext ─────────────────────*/
        SimulationContext ctx = SimulationContext.builder()
                .simulationId(simId)
                .configId(pidCfg != null ? pidCfg.id() : 0)
                .modelId(aiCfg  != null ? aiCfg.id()  : 0)
                .room(room)
                .thermalModel(simpleThermalModel)
                .strategy(strategyRegistry.strategy(type))
                .clock(clock)
                .iterations(dto.iterations())
                .maxHeaterPower(MAX_HEATER_POWER)
                .build();
        simulationRegistry.put(ctx);

        log.info("Start sim {}, controller {}, pidCfg={}, model={}",
                simId, type, pidCfg != null ? pidCfg.id() : "—",
                aiCfg  != null ? aiCfg.id()  : "—");

        /*────────────────── 5. Запускаем движок ───────────────────────────────*/
        engine.run(ctx);

        return simId;
    }
}


package diplom.work.roomsimulatorservice.service.strategies;

import diplom.work.roomsimulatorservice.util.ControllerType;
import diplom.work.roomsimulatorservice.domain.SimulationContext;
import diplom.work.roomsimulatorservice.dto.autotunePidDTO.AutotunePidDtoRequest;
import diplom.work.roomsimulatorservice.dto.autotunePidDTO.AutotunePidDtoResponse;
import diplom.work.roomsimulatorservice.feign.AutotuneClient;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;

@Component
@RequiredArgsConstructor
public class AutotunePidSimulationStrategy implements SimulationStrategy {

    private final AutotuneClient autotuneClient;

    @Override
    public ControllerType getType() {
        return ControllerType.AUTOTUNE_PID;
    }

    @Override
    public double compute(SimulationContext ctx) {
        AutotunePidDtoRequest autotunePidDtoRequest = new AutotunePidDtoRequest(
                ctx.getRoom().getRoomState().getAirTemperature()
        );

        AutotunePidDtoResponse autotunePidDtoResponse = autotuneClient.compute(ctx.getSimulationId(), autotunePidDtoRequest);
        return autotunePidDtoResponse.outputPower();
    }
}


package diplom.work.roomsimulatorservice.service.strategies;

import diplom.work.roomsimulatorservice.config.StrategyProperties;
import diplom.work.roomsimulatorservice.dto.LstmModelDTO.LstmSensorDTO;
import diplom.work.roomsimulatorservice.util.ControllerType;
import diplom.work.roomsimulatorservice.domain.SimulationContext;
import diplom.work.roomsimulatorservice.domain.room.RoomState;
import diplom.work.roomsimulatorservice.dto.LstmModelDTO.LstmModelDtoRequest;
import diplom.work.roomsimulatorservice.dto.PidDTO.PIDRequest;
import diplom.work.roomsimulatorservice.dto.PidDTO.PIDResponse;
import diplom.work.roomsimulatorservice.feign.AiModelsClient;
import diplom.work.roomsimulatorservice.feign.PIDClient;
import diplom.work.roomsimulatorservice.service.calculations.TargetTemperatureCalculation;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

import java.time.LocalDateTime;
import java.util.*;

@Component
@RequiredArgsConstructor
@Slf4j
public class PidLstmSimulationStrategy implements SimulationStrategy {

    private final AiModelsClient aiModelsClient;
    private final PIDClient pidClient;
    private final TargetTemperatureCalculation targetTemperatureCalculation;
    private final StrategyProperties props;   // @ConfigurationProperties

    /*───────────────────────────── ВНУТРЕННЕЕ СОСТОЯНИЕ ─────────────────────────────*/

    private record PidLstmState(
            double               lastCorrectedSetpoint,
            int                  stepsAfterPrediction,
            Deque<LstmSensorDTO> buffer
    ) {
        private static final int MAX = 30;

        PidLstmState() {
            this(0.0, 0, new ArrayDeque<>(MAX));
        }

        PidLstmState(double newSetpoint, int newSteps, PidLstmState prev) {
            this(newSetpoint, newSteps, prev.buffer);
        }

        void push(LstmSensorDTO dto) {
            if (buffer.size() >= MAX) buffer.pollFirst();
            buffer.addLast(dto);
        }

        boolean ready()           { return buffer.size() == MAX; }

        List<LstmSensorDTO> snapshot() { return new ArrayList<>(buffer); }
    }

    @Override
    public ControllerType getType() {
        return ControllerType.PID_LSTM;
    }

    private double predictTemperature(Long modelId, Deque<LstmSensorDTO> seq) {
        LstmModelDtoRequest req = new LstmModelDtoRequest(modelId, new ArrayList<>(seq));
        try {
            return aiModelsClient.predictTemperatureLSTM(req).predictedTemp();
        } catch (Exception e) {
            log.warn("LSTM fallback: {}", e.getMessage());
            return seq.peekLast().tempIn();
        }
    }


    @Override
    public double compute(SimulationContext ctx) {

        PidLstmState st = ctx.state(this, PidLstmState::new);

        RoomState    room     = ctx.getRoom().getRoomState();
        double       dt       = ctx.getClock().dtSeconds();
        LocalDateTime ts      = ctx.getClock().now();

        st.push(new LstmSensorDTO(
                room.getAirTemperature(),
                room.getOutsideTemperature(),
                targetTemperatureCalculation.getTargetTemperature(ts),
                room.getHeaterPower()
        ));

        double userSetpoint = targetTemperatureCalculation.getTargetTemperature(ts);
        double pidSetpoint  = (st.lastCorrectedSetpoint == 0)
                ? userSetpoint
                : st.lastCorrectedSetpoint;

        if (st.ready() && st.stepsAfterPrediction >= props.predictionInterval()) {

            double tPred = predictTemperature(ctx.getModelId(), st.buffer);
            room.setPredictedTemperature(tPred);

            double correction = (tPred - userSetpoint) * props.correctionGain();
            pidSetpoint = userSetpoint - correction;

            st = new PidLstmState(pidSetpoint, 0, st);
        } else {
            st = new PidLstmState(pidSetpoint, st.stepsAfterPrediction + 1, st);
        }

        ctx.putState(this, st);
        room.setSetpointTemperature(pidSetpoint);

        PIDRequest pidReq = new PIDRequest(
                ctx.getSimulationId(),
                ctx.getConfigId(),
                pidSetpoint,
                room.getAirTemperature(),
                dt
        );

        PIDResponse pidResp = pidClient.compute(pidReq);
        return pidResp.outputPower();
    }
}


package diplom.work.roomsimulatorservice.service.strategies;

import diplom.work.roomsimulatorservice.util.ControllerType;
import diplom.work.roomsimulatorservice.domain.SimulationContext;
import diplom.work.roomsimulatorservice.dto.PidDTO.PIDRequest;
import diplom.work.roomsimulatorservice.dto.PidDTO.PIDResponse;
import diplom.work.roomsimulatorservice.feign.PIDClient;
import diplom.work.roomsimulatorservice.service.calculations.TargetTemperatureCalculation;
import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
@RequiredArgsConstructor(onConstructor_ = {@Autowired})
public class PidSimulationStrategy implements SimulationStrategy {

    private final PIDClient pidClient;
    private final TargetTemperatureCalculation targetTemperatureCalculation;

    @Override
    public ControllerType getType() {
        return ControllerType.PID;
    }

    @Override
    public double compute(SimulationContext ctx) {
        double pidSetpoint = targetTemperatureCalculation.getTargetTemperature(ctx.getClock().now()); // Уставка, яка буде подана в PID
        ctx.getRoom().getRoomState().setSetpointTemperature(pidSetpoint);

        PIDRequest pidRequest = new PIDRequest(
                ctx.getSimulationId(),
                ctx.getConfigId(),
                pidSetpoint,
                ctx.getRoom().getRoomState().getAirTemperature(),
                ctx.getClock().dtSeconds()
        );

        PIDResponse pidResponse = pidClient.compute(pidRequest);
        return pidResponse.outputPower();
    }
}


package diplom.work.roomsimulatorservice.service.strategies;

import diplom.work.roomsimulatorservice.util.ControllerType;
import diplom.work.roomsimulatorservice.domain.SimulationContext;
import diplom.work.roomsimulatorservice.dto.RlModelDTO.RlModelDtoRequest;
import diplom.work.roomsimulatorservice.dto.RlModelDTO.RlModelDtoResponse;
import diplom.work.roomsimulatorservice.feign.AiModelsClient;
import diplom.work.roomsimulatorservice.service.calculations.TargetTemperatureCalculation;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;

// RlSimulationStrategy.java – реализация стратегии для управления RL-агентом
@Component
@RequiredArgsConstructor
public class RlSimulationStrategy implements SimulationStrategy {
    private final AiModelsClient aiModelsClient;
    private final TargetTemperatureCalculation targetTemperatureCalculation;

    @Override
    public ControllerType getType() {
        return ControllerType.RL;
    }

    @Override
    public double compute(SimulationContext ctx) {
        double tempSetpoint = targetTemperatureCalculation.getTargetTemperature(ctx.getClock().now());
        ctx.getRoom().getRoomState().setSetpointTemperature(tempSetpoint);

        RlModelDtoRequest rlModelDtoRequest = new RlModelDtoRequest(
                ctx.getModelId(),
                ctx.getRoom().getRoomState().getAirTemperature(),
                ctx.getRoom().getRoomState().getOutsideTemperature()
        );

        RlModelDtoResponse rlModelDtoResponse = aiModelsClient.computeHeatRL(rlModelDtoRequest);
        return rlModelDtoResponse.heaterPower();
    }
}


package diplom.work.roomsimulatorservice.service.strategies;

import diplom.work.roomsimulatorservice.util.ControllerType;
import diplom.work.roomsimulatorservice.domain.SimulationContext;
import org.springframework.stereotype.Component;

@Component
public interface SimulationStrategy {
    ControllerType getType();  // тип контроллера, для регистрации в мапе

    double compute(SimulationContext ctx);
}


package diplom.work.roomsimulatorservice.service.strategies;

import diplom.work.roomsimulatorservice.util.ControllerType;
import lombok.Getter;
import lombok.Setter;
import org.springframework.stereotype.Component;

import java.util.EnumMap;
import java.util.List;
import java.util.Map;

@Component
@Getter
public class StrategyRegistry {
    private final Map<ControllerType, SimulationStrategy> registry =
            new EnumMap<>(ControllerType.class);

    public StrategyRegistry(List<SimulationStrategy> strategies) {
        strategies.forEach(s -> registry.put(s.getType(), s));
    }

    public SimulationStrategy strategy(ControllerType type) {
        SimulationStrategy s = registry.get(type);
        if (s == null) {
            throw new IllegalArgumentException("No strategy registered for " + type);
        }
        return s;
    }

    public Map<ControllerType, SimulationStrategy> all() {
        return Map.copyOf(registry);
    }
}


package diplom.work.roomsimulatorservice.service.strategies;

import diplom.work.roomsimulatorservice.dto.RlTrainDTO.RlTrainDtoResponse;
import diplom.work.roomsimulatorservice.util.ControllerType;
import diplom.work.roomsimulatorservice.domain.SimulationContext;
import diplom.work.roomsimulatorservice.dto.RlModelDTO.RlModelDtoResponse;
import diplom.work.roomsimulatorservice.dto.RlTrainDTO.RlTrainDtoRequest;
import diplom.work.roomsimulatorservice.feign.RlTrainClient;
import diplom.work.roomsimulatorservice.service.calculations.TargetTemperatureCalculation;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

@Slf4j
@Component
@RequiredArgsConstructor
public class TrainRlSimulationStrategy implements SimulationStrategy {
    private final RlTrainClient rlTrainClient;
    private final TargetTemperatureCalculation targetTemperatureCalculation;

    @Override
    public ControllerType getType() {
        return ControllerType.TRAIN_RL;
    }

    @Override
    public double compute(SimulationContext ctx) {
        double tempSetpoint = targetTemperatureCalculation.getTargetTemperature(ctx.getClock().now());
        ctx.getRoom().getRoomState().setSetpointTemperature(tempSetpoint);

        RlTrainDtoRequest rlModelDtoRequest = new RlTrainDtoRequest(
                ctx.getSimulationId(),
                ctx.getRoom().getRoomState().getAirTemperature(),
                ctx.getRoom().getRoomState().getOutsideTemperature(),
                ctx.getRoom().getRoomState().getSetpointTemperature()
        );

        RlTrainDtoResponse rlTrainDtoResponse = rlTrainClient.compute(rlModelDtoRequest);
        log.info("OutputPower: {}", rlTrainDtoResponse.heaterPower());
        return rlTrainDtoResponse.heaterPower();
    }
}

package diplom.work.roomsimulatorservice.service;

import diplom.work.roomsimulatorservice.dto.storage.storage_sensor_client.SensorDataDTO;
import lombok.RequiredArgsConstructor;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class KafkaSensorProducer {
    private final KafkaTemplate<String, SensorDataDTO> kafkaTemplate;

    public void sendSensorData(SensorDataDTO data) {
        kafkaTemplate.send("simulation-data-topic", data.simulationId().toString(), data);
    }
}


spring.application.name=RoomSimulatorService
server.port=8080

simulation.pid-lstm.prediction-interval=15
simulation.pid-lstm.correction-gain=0.9
simulation.pid-lstm.max-setpoint-shift=2

feign.client.config.pid-controller.url= http://localhost:8081

feign.client.config.storage-service.url= http://localhost:8082

feign.client.config.pid-autotuner.url= http://localhost:7000

feign.client.config.RL-trainer.url=http://localhost:7002

feign.client.config.AI-models.url= http://localhost:7003


package diplom.work.controllerservice.controller;

import diplom.work.controllerservice.dto.PIDRequest;
import diplom.work.controllerservice.dto.PIDResponse;
import diplom.work.controllerservice.service.PIDControllerService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/pid")
@RequiredArgsConstructor
public class PIDController {

    private final PIDControllerService pidService;

    @PostMapping("/compute")
    public ResponseEntity<PIDResponse> compute(@RequestBody PIDRequest request) {
        System.out.println(request.toString());
        double outputPower = 0; // 0 - 100%
        try {
            outputPower = pidService.calculateOutput(request);
        } catch (Exception e) {
            return ResponseEntity.status(404).build();
        }
        return ResponseEntity.ok(new PIDResponse(outputPower));
    }
}

package diplom.work.controllerservice.dto;

public record PidConfigDTO(
        Long   id,
        Double kp,
        Double ki,
        Double kd,
        String tunedMethod
) {
}

package diplom.work.controllerservice.dto;

public record PIDRequest(
        Long simulationId,
        Long pidConfigId,
        double targetTemperature,
        double currentTemperature,
        double deltaTime
) {}

package diplom.work.controllerservice.dto;

public record PIDResponse(
        double outputPower
) {}

package diplom.work.controllerservice.feign;

import diplom.work.controllerservice.dto.PidConfigDTO;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;

@FeignClient(name = "storage-service", url = "${feign.client.config.storage-service.url}")
public interface StoragePidConfigClient {

    @GetMapping("/api/pid-configs/{id}")
    ResponseEntity<PidConfigDTO> getConfig(@PathVariable Long id);
}

package diplom.work.controllerservice.model.PidImpl;

import lombok.Getter;
import lombok.Setter;

@Getter
public class MiniPID {

    private double P = 0;
    private double I = 0;
    private double D = 0;
    private double F = 0;

    private final double dt;

    private double maxIOutput = 0;
    private double maxError = 0;
    private double errorSum = 0;

    private double maxOutput = 0;
    private double minOutput = 0;

    @Setter
    private double setpoint = 0;

    private double lastActual = 0;

    private boolean firstRun = true;
    private boolean reversed = false;

    private double outputRampRate = 0;
    private double lastOutput = 0;

    private double outputFilter = 0;

    private double setpointRange = 0;


    public MiniPID(double p, double i, double d, double dt) {
        P = p;
        I = i;
        D = d;
        this.dt = dt;
        checkSigns();
    }


    public MiniPID(double p, double i, double d, double f, double dt) {
        P = p;
        I = i;
        D = d;
        F = f;
        this.dt = dt;
        checkSigns();
    }


    public void setP(double p) {
        P = p;
        checkSigns();
    }


    public void setI(double i) {
        if (I != 0) {
            errorSum = errorSum * I / i;
        }
        if (maxIOutput != 0) {
            maxError = maxIOutput / i;
        }
        I = i;
        checkSigns();

    }

    public void setD(double d) {
        D = d;
        checkSigns();
    }

    public void setF(double f) {
        F = f;
        checkSigns();
    }


    public void setPID(double p, double i, double d) {
        P = p;
        D = d;

        setI(i);
        checkSigns();
    }


    public void setPID(double p, double i, double d, double f) {
        P = p;
        D = d;
        F = f;

        setI(i);
        checkSigns();
    }


    public void setMaxIOutput(double maximum) {
        maxIOutput = maximum;
        if (I != 0) {
            maxError = maxIOutput / I;
        }
    }

    public void setOutputLimits(double output) {
        setOutputLimits(-output, output);
    }

    public void setOutputLimits(double minimum, double maximum) {
        if (maximum < minimum) return;
        maxOutput = maximum;
        minOutput = minimum;

        if (maxIOutput == 0 || maxIOutput > (maximum - minimum)) {
            setMaxIOutput(maximum - minimum);
        }
    }

    public void setDirection(boolean reversed) {
        this.reversed = reversed;
    }

    public double getOutput(double actual, double setpoint, double dt) {
        double output;
        double Poutput;
        double Ioutput;
        double Doutput;
        double Foutput;

        this.setpoint = setpoint;

        if (setpointRange != 0) {
            setpoint = constrain(setpoint, actual - setpointRange, actual + setpointRange);
        }

        double error = setpoint - actual;

        Foutput = F * setpoint;

        Poutput = P * error;

        if (firstRun) {
            lastActual = actual;
            lastOutput = Poutput + Foutput;
            firstRun = false;
        }

        double derivative = (actual - lastActual) / dt;
        Doutput = -D * derivative;
        lastActual = actual;

        Ioutput = I * errorSum;
        if (maxIOutput != 0) {
            Ioutput = constrain(Ioutput, -maxIOutput, maxIOutput);
        }

        output = Foutput + Poutput + Ioutput + Doutput;

        if (minOutput != maxOutput && !bounded(output, minOutput, maxOutput)) {
            errorSum = error;
        } else if (outputRampRate != 0 && !bounded(output, lastOutput - outputRampRate, lastOutput + outputRampRate)) {
            errorSum = error;
        } else if (maxIOutput != 0) {
            errorSum = constrain(errorSum + error * dt, -maxError, maxError);
        } else {
            errorSum += error * dt;
        }

        if (outputRampRate != 0) {
            output = constrain(output, lastOutput - outputRampRate, lastOutput + outputRampRate);
        }
        if (minOutput != maxOutput) {
            output = constrain(output, minOutput, maxOutput);
        }
        if (outputFilter != 0) {
            output = lastOutput * outputFilter + output * (1 - outputFilter);
        }

        lastOutput = output;
        return output;
    }


    public double getOutput() {
        return getOutput(lastActual, setpoint, dt);
    }


    public double getOutput(double actual) {
        return getOutput(actual, setpoint, dt);
    }


    public void reset() {
        firstRun = true;
        errorSum = 0;
    }

    public void setOutputRampRate(double rate) {
        outputRampRate = rate;
    }

    public void setSetpointRange(double range) {
        setpointRange = range;
    }

    public void setOutputFilter(double strength) {
        if (strength == 0 || bounded(strength, 0, 1)) {
            outputFilter = strength;
        }
    }

    private double constrain(double value, double min, double max) {
        if (value > max) {
            return max;
        }
        if (value < min) {
            return min;
        }
        return value;
    }

    private boolean bounded(double value, double min, double max) {
        return (min < value) && (value < max);
    }

    private void checkSigns() {
        if (reversed) {
            if (P > 0) P *= -1;
            if (I > 0) I *= -1;
            if (D > 0) D *= -1;
            if (F > 0) F *= -1;
        } else {
            if (P < 0) P *= -1;
            if (I < 0) I *= -1;
            if (D < 0) D *= -1;
            if (F < 0) F *= -1;
        }
    }
}


package diplom.work.controllerservice.service;

import diplom.work.controllerservice.dto.PIDRequest;
import diplom.work.controllerservice.dto.PidConfigDTO;
import diplom.work.controllerservice.feign.StoragePidConfigClient;
import diplom.work.controllerservice.model.PidImpl.MiniPID;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

@Service
@RequiredArgsConstructor
@Slf4j
public class PIDControllerService {

    private final Map<Long, MiniPID> pidStates = new ConcurrentHashMap<>();
    private final StoragePidConfigClient storagePidConfigClient;

    public double calculateOutput(PIDRequest request) {
        MiniPID pidState = pidStates.get(request.simulationId());
        if (pidState == null) {
            PidConfigDTO pidConfigDTO = storagePidConfigClient.getConfig(request.pidConfigId()).getBody();
            if (pidConfigDTO != null) {
                pidState = new MiniPID(pidConfigDTO.kp(), pidConfigDTO.ki(), pidConfigDTO.kd(), request.deltaTime());
                pidState.setOutputLimits(0.0, 100.0);
                pidState.setMaxIOutput(30.0);
                pidStates.put(request.simulationId(), pidState);
            } else throw new RuntimeException("PID config not found");
        }
        log.info("Kp: {} Ki: {} Kd: {}", pidState.getP(), pidState.getI(), pidState.getD());

        return pidState.getOutput(request.currentTemperature(), request.targetTemperature(), request.deltaTime());
    }
}

spring.application.name=ControllerService
server.port=8081

feign.client.config.storage-service.url= http://localhost:8082

package diplom.work.storageservice.config;

import diplom.work.storageservice.dto.sensor_data.SensorDataDTO;
import org.apache.kafka.clients.consumer.ConsumerConfig;
import org.apache.kafka.common.serialization.StringDeserializer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.kafka.annotation.EnableKafka;
import org.springframework.kafka.config.ConcurrentKafkaListenerContainerFactory;
import org.springframework.kafka.config.KafkaListenerContainerFactory;
import org.springframework.kafka.core.ConsumerFactory;
import org.springframework.kafka.core.DefaultKafkaConsumerFactory;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.kafka.core.ProducerFactory;
import org.springframework.kafka.listener.ConcurrentMessageListenerContainer;
import org.springframework.kafka.listener.ContainerProperties;
import org.springframework.kafka.listener.DeadLetterPublishingRecoverer;
import org.springframework.kafka.listener.DefaultErrorHandler;
import org.springframework.kafka.support.serializer.DeserializationException;
import org.springframework.kafka.support.serializer.JsonDeserializer;
import org.springframework.util.backoff.FixedBackOff;

import java.util.HashMap;
import java.util.Map;

@Configuration
@EnableKafka
public class KafkaConsumerProdConfig {

    @Bean
    public Map<String, Object> consumerConfig() {
        Map<String, Object> props = new HashMap<>();
        props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, "localhost:9092");
        props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);
        props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, JsonDeserializer.class);

        props.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, false);
        props.put(ConsumerConfig.GROUP_ID_CONFIG, "storage-group");
        props.put(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, "500");
        props.put(JsonDeserializer.TRUSTED_PACKAGES, "diplom.work.storageservice.dto.sensor_data");
        props.put(JsonDeserializer.VALUE_DEFAULT_TYPE, "diplom.work.storageservice.dto.sensor_data.SensorDataDTO");
        props.put(JsonDeserializer.USE_TYPE_INFO_HEADERS, false); //если надо отключить type headers
        return props;
    }

    @Bean
    public ConsumerFactory<String, SensorDataDTO> consumerFactory() {
        return new DefaultKafkaConsumerFactory<>(consumerConfig());
    }

    @Bean
    public KafkaListenerContainerFactory<
            ConcurrentMessageListenerContainer<String, SensorDataDTO>
            > kafkaListenerContainerFactory(
            KafkaTemplate<String, Object> kafkaTemplate // <--- добавь сюда!
    ) {
        ConcurrentKafkaListenerContainerFactory<String, SensorDataDTO> factory =
                new ConcurrentKafkaListenerContainerFactory<>();

        factory.setConsumerFactory(consumerFactory());
        factory.setConcurrency(3);
        factory.getContainerProperties().setAckMode(ContainerProperties.AckMode.MANUAL);

        DefaultErrorHandler errorHandler = new DefaultErrorHandler(
                new DeadLetterPublishingRecoverer(kafkaTemplate),
                new FixedBackOff(5_000L, 3)
        );
        errorHandler.addNotRetryableExceptions(DeserializationException.class);
        factory.setCommonErrorHandler(errorHandler);

        return factory;
    }

    @Bean
    public KafkaTemplate<String, Object> kafkaTemplate(
            ProducerFactory<String, Object> pf
    ) {
        return new KafkaTemplate<>(pf);
    }
}

package diplom.work.storageservice.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class WebConfig implements WebMvcConfigurer {
    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/api/**")
                .allowedOrigins("http://localhost:3000")
                .allowedMethods("GET","POST","PUT","DELETE","OPTIONS")
                .allowedHeaders("*")
                .allowCredentials(true);
    }
}


package diplom.work.storageservice.controller.ai_model;

import diplom.work.storageservice.dto.ai_model.AiModelDTO;
import diplom.work.storageservice.dto.ai_model.AiModelListResponseDTO;
import diplom.work.storageservice.model.ai_model.AiModel;
import diplom.work.storageservice.service.ai_model.AiModelService;
import diplom.work.storageservice.util.AiModelMapper;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/models")
@RequiredArgsConstructor
public class AiModelController {

    private final AiModelService aiModelService;
    private final AiModelMapper aiModelMapper;

    @GetMapping()
    public ResponseEntity<AiModelListResponseDTO> getAllModels() {
        return ResponseEntity.status(200).body(
                new AiModelListResponseDTO(
                        aiModelService.findAllModels()
                                .stream()
                                .map(aiModelMapper::toDto)
                                .toList()));
    }

    @GetMapping("/room-models/{roomId}")
    public ResponseEntity<AiModelListResponseDTO> getAllConfigsByRoom(@PathVariable Long roomId) {
        return ResponseEntity.status(200).body(
                new AiModelListResponseDTO(
                        aiModelService.findAllByRoom(roomId)
                                .stream()
                                .map(aiModelMapper::toDto)
                                .toList()));
    }

    @PostMapping("/room-models/{roomId}")
    public ResponseEntity<AiModelDTO> createModel(@PathVariable Long roomId,
                                                  @RequestBody AiModelDTO aiModelDTO) {
        AiModel aiModel = aiModelMapper.toEntity(aiModelDTO);

        return ResponseEntity.status(201).body(
                aiModelMapper.toDto(
                        aiModelService.create(roomId, aiModel)));
    }

    @GetMapping("/{id}")
    public ResponseEntity<AiModelDTO> getAiModelById(@PathVariable Long id) {
        return aiModelService.findById(id)
                .map(aiModelMapper::toDto)
                .map(ResponseEntity::ok)
                .orElse(ResponseEntity.notFound().build());
    }

    @PatchMapping("/{modelId}")
    public ResponseEntity<?> update(@PathVariable Long modelId,
                                    @RequestBody AiModelDTO aiModelDTO) {
        AiModel aiModel = aiModelMapper.toEntity(aiModelDTO);

        try {
            return ResponseEntity.ok(
                    aiModelMapper.toDto(
                            aiModelService.updateModel(modelId, aiModel)));
        } catch (RuntimeException e) {
            return ResponseEntity.status(404).body(e.getMessage());
        }
    }

    @DeleteMapping("/{modelId}")
    public ResponseEntity<?> delete(@PathVariable Long modelId) {
        try {
            aiModelService.deleteModel(modelId);
            return ResponseEntity.noContent().build();
        } catch (RuntimeException e) {
            return ResponseEntity.status(404).body(e.getMessage());
        }
    }
}

package diplom.work.storageservice.controller.pid_config;

import diplom.work.storageservice.dto.ai_model.AiModelDTO;
import diplom.work.storageservice.dto.pid_config.PidConfigDTO;
import diplom.work.storageservice.dto.pid_config.PidConfigListResponseDTO;
import diplom.work.storageservice.model.pid_config.PidConfig;
import diplom.work.storageservice.service.pid_config.PidConfigService;
import diplom.work.storageservice.util.PidConfigMapper;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/pid-configs")
@RequiredArgsConstructor
@Validated
public class PidConfigController {

    private final PidConfigMapper pidConfigMapper;
    private final PidConfigService pidConfigService;

    @GetMapping()
    public ResponseEntity<PidConfigListResponseDTO> getAllConfigs() {
        return ResponseEntity.status(200).body(
                new PidConfigListResponseDTO(
                        pidConfigService.findAllConfigs()
                                .stream()
                                .map(pidConfigMapper::toDto)
                                .toList()));
    }

    @GetMapping("/room-configs/{roomId}")
    public ResponseEntity<PidConfigListResponseDTO> getAllConfigsByRoom(@PathVariable Long roomId) {
        return ResponseEntity.status(200).body(
                new PidConfigListResponseDTO(
                        pidConfigService.findAllByRoom(roomId)
                                .stream()
                                .map(pidConfigMapper::toDto)
                                .toList()));
    }

    @GetMapping("/room-configs/{roomId}/active")
    public ResponseEntity<PidConfigDTO> getActive(@PathVariable Long roomId) {
        return pidConfigService.getActive(roomId)
                .map(pidConfigMapper::toDto)
                .map(ResponseEntity::ok)
                .orElse(ResponseEntity.noContent().build());
    }

    @PostMapping("/room-configs/{roomId}")
    public ResponseEntity<PidConfigDTO> create(@PathVariable Long roomId,
                                               @RequestBody PidConfigDTO dto) {

        dto = new PidConfigDTO(
                dto.id(),
                Math.round(dto.kp() * 1000) / 1000.0,
                Math.round(dto.ki() * 1000) / 1000.0,
                Math.round(dto.kd() * 1000) / 1000.0,
                dto.tunedMethod(),
                dto.active()
        );

        PidConfig pidConfig = pidConfigMapper.toEntity(dto);
        return ResponseEntity.status(201).body(
                pidConfigMapper.toDto(
                        pidConfigService.createManual(roomId, pidConfig)));
    }

    @GetMapping("/{id}")
    public ResponseEntity<PidConfigDTO> getConfigById(@PathVariable Long id) {
        var config = pidConfigService.findById(id)
                .map(pidConfigMapper::toDto)
                .map(ResponseEntity::ok);
        return config.orElse(ResponseEntity.notFound().build());
    }

    @PutMapping("/{configId}")
    public ResponseEntity<?> update(@PathVariable Long configId,
                                    @RequestBody PidConfigDTO pidConfigDTO) {
        PidConfig pidConfig = pidConfigMapper.toEntity(pidConfigDTO);

        try {
            return ResponseEntity.ok(
                    pidConfigMapper.toDto(
                            pidConfigService.updateConfig(configId, pidConfig)));
        } catch (RuntimeException e) {
            return ResponseEntity.status(404).body(e.getMessage());
        }
    }

    @DeleteMapping("/{configId}")
    public ResponseEntity<?> delete(@PathVariable Long configId) {
        try {
            pidConfigService.deleteConfig(configId);
            return ResponseEntity.noContent().build();
        } catch (RuntimeException e) {
            return ResponseEntity.status(404).body(e.getMessage());
        }
    }
}


package diplom.work.storageservice.controller.room;

import diplom.work.storageservice.dto.room.RoomDTO;
import diplom.work.storageservice.dto.room.RoomListResponseDTO;
import diplom.work.storageservice.model.room.Room;
import diplom.work.storageservice.service.room.RoomService;
import diplom.work.storageservice.util.RoomMapper;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/rooms")
@RequiredArgsConstructor
public class RoomController {

    private final RoomMapper roomMapper;
    private final RoomService roomService;

    @PostMapping("/{userId}")
    public ResponseEntity<RoomDTO> saveRoom(@PathVariable Long userId,
                                            @RequestBody RoomDTO roomDTO) {
        System.out.println(roomDTO.toString());
        Room room = roomMapper.toEntity(roomDTO);

        return ResponseEntity.status(201).body(
                roomMapper.toDto(
                        roomService.create(userId, room)));
    }

    @GetMapping()
    public ResponseEntity<RoomListResponseDTO> getAllRooms() {
        return ResponseEntity.status(200).body(
                new RoomListResponseDTO(
                        roomService.findAllRooms()
                                .stream()
                                .map(roomMapper::toDto)
                                .toList()));
    }

    @GetMapping("/user-rooms/{userId}")
    public ResponseEntity<RoomListResponseDTO> getAllRoomsByUserId(@PathVariable Long userId) {
        return ResponseEntity.status(200).body(
                new RoomListResponseDTO(
                        roomService.findAllByUser(userId)
                                .stream()
                                .map(roomMapper::toDto)
                                .toList()));
    }

    @GetMapping("/{id}")
    public ResponseEntity<RoomDTO> getRoomById(@PathVariable Long id) {
        return roomService.findRoomById(id)
                .map(roomMapper::toDto)
                .map(ResponseEntity::ok)
                .orElse(ResponseEntity.notFound().build());
    }

    @PatchMapping("/{id}")
    public ResponseEntity<?> updateRoom(@PathVariable Long id,
                                        @RequestBody RoomDTO roomDTO) {
        Room roomDetails = roomMapper.toEntity(roomDTO);

        try {
            return ResponseEntity.ok(
                    roomMapper.toDto(
                            roomService.updateRoom(id, roomDetails)));
        } catch (RuntimeException e) {
            return ResponseEntity.status(404).body(e.getMessage());
        }
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<?> deleteRoom(@PathVariable Long id) {
        try {
            roomService.deleteRoom(id);
            return ResponseEntity.noContent().build();
        } catch (RuntimeException e) {
            return ResponseEntity.status(404).body(e.getMessage());
        }
    }
}


package diplom.work.storageservice.controller.sensor_data;

import diplom.work.storageservice.dto.sensor_data.MetricsDTO;
import diplom.work.storageservice.service.sensor_data.MetricsService;
import lombok.RequiredArgsConstructor;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/simulations")
@RequiredArgsConstructor
public class MetricsController {

    private final MetricsService metrics;

    @GetMapping("/{id}/metrics")
    public MetricsDTO metrics(@PathVariable long id) {
        return metrics.calc(id);
    }
}

package diplom.work.storageservice.controller.sensor_data;

import diplom.work.storageservice.dto.sensor_data.SensorDataDTO;
import diplom.work.storageservice.dto.sensor_data.SensorDataListResponseDTO;
import diplom.work.storageservice.dto.sensor_data.SensorDataPageDTO;
import diplom.work.storageservice.model.sensor_data.SensorData;
import diplom.work.storageservice.service.sensor_data.SensorDataService;
import diplom.work.storageservice.util.SensorDataMapper;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/sensor-data")
@RequiredArgsConstructor
public class SensorDataController {

    private final SensorDataMapper sensorDataMapper;
    private final SensorDataService sensorDataService;

    // Получить все SensorData по simulationId
    @GetMapping("/simulation-data/all/{simulationId}")
    public ResponseEntity<SensorDataListResponseDTO> getBySimulationIdAllData(@PathVariable Long simulationId) {
        return ResponseEntity.status(200).body(
                new SensorDataListResponseDTO(
                        sensorDataService.getAllBySimulationId(simulationId)
                                .stream()
                                .map(sensorDataMapper::toDto)
                                .toList()));
    }

    @GetMapping("/simulation-data/{simulationId}")
    public ResponseEntity<?> getPage(
            @PathVariable Long simulationId,
            @RequestParam(defaultValue = "0")  int page,
            @RequestParam(defaultValue = "1000") int size) {

        Page<SensorData> p = sensorDataService.getPage(simulationId, page, size);

        return ResponseEntity.ok(
                Map.of(
                        "data",           p.getContent().stream()
                                .map(sensorDataMapper::toDto).toList(),
                        "page",           p.getNumber(),
                        "size",           p.getSize(),
                        "totalPages",     p.getTotalPages(),
                        "totalElements",  p.getTotalElements()
                ));
    }

    @GetMapping("/simulation-data/{simulationId}/last")
    public ResponseEntity<SensorDataDTO> getLastBySimulationId(@PathVariable Long simulationId) {
        return ResponseEntity.status(200).body(
                sensorDataMapper.toDto(
                        sensorDataService.getLastBySimulationId(simulationId)));
    }

    // Добавить шаг симуляции
    @PostMapping("/simulation-data/{simulationId}/step")
    public ResponseEntity<SensorDataDTO> addStep(@PathVariable Long simulationId,
                                                 @RequestBody SensorDataDTO sensorDataDTO) {
        SensorData sensorData = sensorDataMapper.toEntity(sensorDataDTO);

        return ResponseEntity.status(201).body(
                sensorDataMapper.toDto(
                        sensorDataService.save(simulationId, sensorData)));
    }

    // Batch insert (несколько записей)
    @PostMapping("/simulation-data/{simulationId}/batch")
    public ResponseEntity<Void> addBatch(@PathVariable Long simulationId,
                                         @RequestBody List<SensorDataDTO> sensorDataDtoList) {
        List<SensorData> sensorData = sensorDataDtoList.stream()
                .map(sensorDataMapper::toEntity)
                .toList();

        sensorDataService.addBatch(simulationId, sensorData);

        return ResponseEntity.status(201).build();
    }
}


package diplom.work.storageservice.controller.simulation;

import diplom.work.storageservice.dto.room.RoomDTO;
import diplom.work.storageservice.dto.room.RoomListResponseDTO;
import diplom.work.storageservice.dto.simulation.SimulationDTO;
import diplom.work.storageservice.dto.simulation.SimulationListResponseDTO;
import diplom.work.storageservice.model.room.Room;
import diplom.work.storageservice.model.simulation.Simulation;
import diplom.work.storageservice.service.room.RoomService;
import diplom.work.storageservice.service.simulation.SimulationService;
import diplom.work.storageservice.util.RoomMapper;
import diplom.work.storageservice.util.SimulationMapper;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/simulations")
@RequiredArgsConstructor
public class SimulationController {

    private final SimulationMapper simulationMapper;
    private final SimulationService simulationService;

    @PostMapping("/{roomId}")
    public ResponseEntity<SimulationDTO> saveSimulation(@PathVariable Long roomId,
                                                        @RequestBody SimulationDTO simulationDTO) {
        Simulation simulation = simulationMapper.toEntity(simulationDTO);

        return ResponseEntity.status(201).body(
                simulationMapper.toDto(
                        simulationService.create(roomId, simulation)));
    }

    @GetMapping()
    public ResponseEntity<SimulationListResponseDTO> getAllSimulations() {
        return ResponseEntity.status(200).body(
                new SimulationListResponseDTO(
                        simulationService.findAllSimulations()
                                .stream()
                                .map(simulationMapper::toDto)
                                .toList()));
    }

    @GetMapping("/room-simulations/{roomId}")
    public ResponseEntity<SimulationListResponseDTO> getAllSimulationsByRoomId(@PathVariable Long roomId) {
        return ResponseEntity.status(200).body(
                new SimulationListResponseDTO(
                        simulationService.findAllByRoom(roomId)
                                .stream()
                                .map(simulationMapper::toDto)
                                .toList()));
    }

    @GetMapping("/{id}")
    public ResponseEntity<SimulationDTO> getSimulationById(@PathVariable Long id) {
        return simulationService.findSimulationById(id)
                .map(simulationMapper::toDto)
                .map(ResponseEntity::ok)
                .orElse(ResponseEntity.notFound().build());
    }

    @PutMapping("/{id}")
    public ResponseEntity<?> updateSimulation(@PathVariable Long id,
                                        @RequestBody SimulationDTO simulationDTO) {
        Simulation simulationDetails = simulationMapper.toEntity(simulationDTO);

        try {
            return ResponseEntity.ok(
                    simulationMapper.toDto(
                            simulationService.updateSimulation(id, simulationDetails)));
        } catch (RuntimeException e) {
            return ResponseEntity.status(404).body(e.getMessage());
        }
    }

    @PutMapping("/running/{id}")
    public ResponseEntity<SimulationDTO> markRunning(@PathVariable Long id) {
        Simulation sim = simulationService.setStatus(id, Simulation.Status.RUNNING);
        return ResponseEntity.ok(SimulationDTO.fromEntity(sim));
    }

    @PutMapping("/finished/{id}")
    public ResponseEntity<SimulationDTO> markFinished(@PathVariable Long id) {
        Simulation sim = simulationService.setStatus(id, Simulation.Status.FINISHED);
        return ResponseEntity.ok(SimulationDTO.fromEntity(sim));
    }

    @PutMapping("/failed/{id}")
    public ResponseEntity<SimulationDTO> markFailed(@PathVariable Long id) {
        Simulation sim = simulationService.setStatus(id, Simulation.Status.FAILED);
        return ResponseEntity.ok(SimulationDTO.fromEntity(sim));
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<?> deleteSimulation(@PathVariable Long id) {
        try {
            simulationService.deleteSimulation(id);
            return ResponseEntity.noContent().build();
        } catch (RuntimeException e) {
            return ResponseEntity.status(404).body(e.getMessage());
        }
    }
}

package diplom.work.storageservice.controller.user;

import diplom.work.storageservice.dto.user.*;
import diplom.work.storageservice.model.user.User;
import diplom.work.storageservice.service.user.UserService;
import diplom.work.storageservice.util.UserMapper;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.Optional;


@RestController
@RequestMapping("/api/users")
@RequiredArgsConstructor
public class UserController {

    private final UserMapper userMapper;
    private final UserService userService;

    @PostMapping("/register")
    public ResponseEntity<?> registerUser(@RequestBody UserRegisterDTO userDTO) {
        User user = userMapper.toEntity(userDTO);

        return ResponseEntity.status(201).body(
                userMapper.toDto(
                        userService.registerUser(user)));
    }

    @PostMapping("/login")
    public ResponseEntity<UserResponseDTO> loginUser(@RequestBody UserAuthDTO userDTO) {
        User user = userService.loginUser(userDTO.email(), userDTO.password());
        return ResponseEntity.ok(userMapper.toDto(user));
    }


    @GetMapping("/email/{email}")
    public ResponseEntity<UserResponseDTO> getUserByEmail(@PathVariable String email) {
        return userService.findByEmail(email)
                .map(userMapper::toDto)
                .map(ResponseEntity::ok)
                .orElse(ResponseEntity.notFound().build());
    }

    @GetMapping("/username/{username}")
    public ResponseEntity<UserResponseDTO> getUserByUsername(@PathVariable String username) {
        return userService.findByUsername(username)
                .map(userMapper::toDto)
                .map(ResponseEntity::ok)
                .orElse(ResponseEntity.notFound().build());
    }

    @GetMapping()
    public ResponseEntity<UserListResponseDTO> getAllUsers() {
        return ResponseEntity.status(200).body(
                new UserListResponseDTO(
                        userService.findAllUsers()
                                .stream()
                                .map(userMapper::toDto)
                                .toList()));
    }

    @GetMapping("/{id}")
    public ResponseEntity<UserResponseDTO> getUserById(@PathVariable Long id) {
        return userService.findUserById(id)
                .map(userMapper::toDto)
                .map(ResponseEntity::ok)
                .orElse(ResponseEntity.notFound().build());
    }

    @PatchMapping("/{id}")
    public ResponseEntity<?> updateUser(@PathVariable Long id,
                                        @RequestBody UserUpdateDTO userDTO) {
        User userDetails = userMapper.toEntity(userDTO);

        try {
            return ResponseEntity.ok(
                    userMapper.toDto(
                            userService.updateUser(id, userDetails)));
        } catch (RuntimeException e) {
            return ResponseEntity.status(404).body(e.getMessage());
        }
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<?> deleteUser(@PathVariable Long id) {
        try {
            userService.deleteUser(id);
            return ResponseEntity.noContent().build();
        } catch (RuntimeException e) {
            return ResponseEntity.status(404).body(e.getMessage());
        }
    }
}


package diplom.work.storageservice.dto.ai_model;

public record AiModelDTO(
        Long id,
        String type,
        String path,
        String description,
        Boolean active
) {
}

package diplom.work.storageservice.dto.ai_model;

import java.util.List;

public record AiModelListResponseDTO(List<AiModelDTO> models) {
}

package diplom.work.storageservice.dto.pid_config;

public record PidConfigDTO(
        Long   id,
        Double kp,
        Double ki,
        Double kd,
        String tunedMethod,
        Boolean active
) {
}

package diplom.work.storageservice.dto.pid_config;

import java.util.List;

public record PidConfigListResponseDTO(List<PidConfigDTO> configs) {
}


package diplom.work.storageservice.dto.room;

import diplom.work.storageservice.model.room.RoomParams;

public record RoomDTO(
        Long id,
        String name,
        RoomParams roomParams
) {
}

package diplom.work.storageservice.dto.room;

import java.util.List;

public record RoomListResponseDTO(List<RoomDTO> rooms) {
}

package diplom.work.storageservice.dto.sensor_data;

public record MetricsDTO(
        double mae,     // Mean-Absolute-Error (°C)
        double mse,     // Mean-Squared-Error (°C²)
        double rmse,    // Root-MSE (°C)
        double energyKWh, // кВт·ч
        double overshoot, // максимальне перерегулювання, °C
        double settlingTimeS   // cекунди (-1 якщо система не вклалась у ±ε)
) {}

package diplom.work.storageservice.dto.sensor_data;

import java.time.LocalDateTime;

public record SensorDataDTO(
        Long simulationId,
        LocalDateTime timestamp,
        Double tempIn,
        Double tempOut,
        Double tempSetpoint,
        Double heaterPower,
        Double predictedTemp,
        Boolean isWindowOpen,
        Boolean isDoorOpen,
        Integer peopleCount
) {
}

package diplom.work.storageservice.dto.sensor_data;

import diplom.work.storageservice.dto.simulation.SimulationDTO;

import java.util.List;

public record SensorDataListResponseDTO(List<SensorDataDTO> sensorDataList) {
}

package diplom.work.storageservice.dto.sensor_data;

import java.util.List;

public record SensorDataPageDTO(
        List<SensorDataDTO> data,  
        int  page,                
        int  size,             
        int  totalPages,      
        long totalElements    
) {}

package diplom.work.storageservice.dto.simulation;

import diplom.work.storageservice.model.simulation.Simulation;

public record SimulationDTO(
        Long id,
        Simulation.Status status,
        Simulation.ControllerType controllerType,
        Long iterations,
        Integer timestepSeconds
) {
    public static SimulationDTO fromEntity(Simulation s) {
        return new SimulationDTO(
                s.getId(),
                s.getStatus(),
                s.getControllerType(),
                s.getIterations(),
                s.getTimestepSeconds()
        );
    }

    public Simulation toEntity() {
        Simulation s = new Simulation();
        s.setId(id);
        s.setStatus(status);
        s.setControllerType(controllerType);
        s.setIterations(iterations);
        s.setTimestepSeconds(timestepSeconds);
        return s;
    }
}

package diplom.work.storageservice.dto.simulation;

import java.util.List;

public record SimulationListResponseDTO(List<SimulationDTO> simulations) {
}

package diplom.work.storageservice.dto.user;

public record UserAuthDTO(String email,
                          String password) {
}

package diplom.work.storageservice.dto.user;

import java.util.List;

public record UserListResponseDTO(List<UserResponseDTO> users) {
}

package diplom.work.storageservice.dto.user;

public record UserRegisterDTO (String username,
                               String password,
                               String email) {
}

package diplom.work.storageservice.dto.user;

public record UserResponseDTO(Long id,
                              String username,
                              String email) {
}


package diplom.work.storageservice.dto.user;

public record UserUpdateDTO(String username,
                            String password,
                            String email) {
}

package diplom.work.storageservice.model.ai_model;

import diplom.work.storageservice.model.room.Room;
import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "models")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class AiModel {
    @Id
    @Column(name = "id")
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "type", length = 16)
    private String type;

    @Column(name = "path")
    private String path;

    @Column(name = "description")
    private String description;

    @Column(name = "is_active")
    private boolean active = true;

    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "room_id", nullable = false)
    private Room room;
}


package diplom.work.storageservice.model.pid_config;

import diplom.work.storageservice.model.room.Room;
import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "pid_configs")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class PidConfig {
    @Id
    @Column(name = "id")
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "kp", nullable = false, scale = 3)
    private double kp;

    @Column(name = "ki", nullable = false, scale = 3)
    private double ki;

    @Column(name = "kd", nullable = false, scale = 3)
    private double kd;

    @Column(name = "tuned_method", length = 32)
    private String tunedMethod;

    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "room_id", nullable = false)
    private Room room;

    @Column(name = "is_active")
    private boolean active = true;
}

package diplom.work.storageservice.model.room;


import diplom.work.storageservice.model.ai_model.AiModel;
import diplom.work.storageservice.model.pid_config.PidConfig;
import diplom.work.storageservice.model.simulation.Simulation;
import diplom.work.storageservice.model.user.User;
import jakarta.persistence.*;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import org.hibernate.annotations.JdbcTypeCode;
import org.hibernate.type.SqlTypes;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "rooms")
@Getter
@Setter
@NoArgsConstructor
public class Room implements Serializable {
    @Id
    @Column(name = "id")
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "name", nullable = false)
    private String name;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id")
    private User user;

    @Column(name = "room_params", nullable = false)
    @JdbcTypeCode(SqlTypes.JSON)
    private RoomParams roomParams;

    @OneToMany(mappedBy = "room", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<Simulation> simulations = new ArrayList<>();

    @OneToMany(mappedBy = "room", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<PidConfig> pidConfigs = new ArrayList<>();

    @OneToMany(mappedBy = "room", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<AiModel> aiModels = new ArrayList<>();
}

package diplom.work.storageservice.model.room;


import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import jakarta.persistence.*;
import lombok.*;

import java.io.Serializable;
import java.util.List;

@Getter
@AllArgsConstructor
@Builder
public class RoomParams implements Serializable {
    private final double volume;
    private final List<SurfaceParams> surfaces;
    private final double airDensity;
    private final double airSpecificHeat;

    private final double airVolume;
    private final double airMass;
    private final double airHeatCapacity;

    @JsonCreator
    public RoomParams(
            @JsonProperty("volume")          double volume,
            @JsonProperty("airDensity")      double airDensity,
            @JsonProperty("airSpecificHeat") double airSpecificHeat,
            @JsonProperty("surfaces")        List<SurfaceParams> surfaces
    ) {
        this.volume          = volume;
        this.airDensity      = airDensity;
        this.airSpecificHeat = airSpecificHeat;
        this.surfaces        = surfaces;

        this.airVolume       = volume;
        this.airMass         = airDensity * volume;
        this.airHeatCapacity = airMass * airSpecificHeat;
    }
}


package diplom.work.storageservice.model.room;

import com.fasterxml.jackson.annotation.JsonAlias;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Builder;
import lombok.Getter;
import lombok.ToString;

import java.io.Serializable;
import java.util.List;

@Getter
@ToString
public class SurfaceParams implements Serializable {
    private final String name;

    private final double area;          // A
    private final double thickness; // d
    private final double density; // p = m/V

    @JsonProperty("uInternal")
    private final double uInternal;     // U внутренняя сторона
    @JsonProperty("uExternal")
    private final double uExternal;     // U внешняя сторона
    private final double thermalConductivity; // k_lambda // λ
    private final double specificHeat; // c
    private final double mass; // m = ρ · A · d
    private final double heatCapacity;  // C = c * m
    private final double totalU; // U // U = 1 / (1/Uвнутр + d/λ + 1/Uвнеш)

    private final String adjacentRoomName; // null или имя другой комнаты (если это внутренняя поверхность)

    @JsonProperty("uInternal")
    public double getUInternal() { return uInternal; }

    @JsonProperty("uExternal")
    public double getUExternal() { return uExternal; }

    @JsonCreator
    public SurfaceParams(@JsonProperty("name") String name,
                         @JsonProperty("area") double area,
                         @JsonProperty("thickness") double thickness,
                         @JsonProperty("density") double density,
                         @JsonProperty("uInternal") @JsonAlias("uinternal") double uInternal,
                         @JsonProperty("uExternal") @JsonAlias("uexternal") double uExternal,
                         @JsonProperty("thermalConductivity") double thermalConductivity,
                         @JsonProperty("specificHeat") double specificHeat,
                         @JsonProperty("adjacentRoomName") String adjacentRoomName) {
        this.name = name;
        this.area = area;
        this.thickness = thickness;
        this.density = density;
        this.uInternal = uInternal;
        this.uExternal = uExternal;
        this.thermalConductivity = thermalConductivity;
        this.specificHeat = specificHeat;
        this.adjacentRoomName = adjacentRoomName;

        this.mass = density * area * thickness;
        this.heatCapacity = specificHeat * mass;
        this.totalU = 1.0 / (1.0 / uInternal + thickness / thermalConductivity + 1.0 / uExternal);
    }
}


package diplom.work.storageservice.model.sensor_data;

import diplom.work.storageservice.model.room.Room;
import diplom.work.storageservice.model.simulation.Simulation;
import jakarta.persistence.*;
import lombok.*;

import java.time.LocalDateTime;

@Entity
@Table(name = "simulation_events")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class SensorData {

    @Id
    @Column(name = "id")
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "simulation_id")
    private Simulation simulation;

    @Column(name = "timestamp")
    private LocalDateTime timestamp;

    @Column(name = "temp_in")
    private Double tempIn;

    @Column(name = "temp_out")
    private Double tempOut;

    @Column(name = "temp_setpoint")
    private Double tempSetpoint;

    @Column(name = "heater_power")
    private Double heaterPower;

    @Column(name = "predicted_temp")
    private Double predictedTemp;

    @Column(name = "is_window_open")
    private Boolean isWindowOpen;

    @Column(name = "is_door_open")
    private Boolean isDoorOpen;

    @Column(name = "people_count")
    private Integer peopleCount;
}


package diplom.work.storageservice.model.simulation;

import diplom.work.storageservice.model.room.Room;
import diplom.work.storageservice.model.sensor_data.SensorData;
import jakarta.persistence.*;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "simulations")
@Getter
@Setter
@NoArgsConstructor
public class Simulation implements Serializable {
    @Id
    @Column(name = "id")
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Enumerated(EnumType.STRING)
    @Column(name = "controller_type")
    private ControllerType controllerType;

    @Enumerated(EnumType.STRING)
    @Column(name = "status")
    private Status status = Status.CREATED;

    @Column(name = "iterations")
    private Long iterations;

    @Column(name = "timestep_seconds")
    private Integer timestepSeconds;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "room_id")
    private Room room;

    @OneToMany(mappedBy = "simulation", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<SensorData> events = new ArrayList<>();

    public enum Status { CREATED, RUNNING, FINISHED, FAILED }
    public enum ControllerType { PID, PID_LSTM, RL, TRAIN_RL, AUTOTUNE_PID }
}

package diplom.work.storageservice.model.user;

import diplom.work.storageservice.model.room.Room;
import jakarta.persistence.*;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.ToString;

import java.io.Serializable;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "users")
@Getter
@Setter
@NoArgsConstructor
public class User implements Serializable {
    @Id
    @Column(name = "id")
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "username", unique = true, nullable = false)
    private String username;

    @Column(name = "password_hash")
    private String password;

    @Column(name = "email", unique = true, nullable = false)
    private String email;

    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<Room> rooms = new ArrayList<>();

    public User(String username, String password, String email) {
        this.username = username;
        this.password = password;
        this.email = email;
    }
}

package diplom.work.storageservice.repository.ai_model;

import diplom.work.storageservice.model.ai_model.AiModel;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface AiModelRepository extends JpaRepository<AiModel, Long> {
    List<AiModel> findAllByRoomId(Long roomId);
}

package diplom.work.storageservice.repository.pid_config;

import diplom.work.storageservice.model.pid_config.PidConfig;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

public interface PidConfigRepository extends JpaRepository<PidConfig, Long> {
    List<PidConfig> findByRoomIdOrderByIdDesc(Long roomId);

    Optional<PidConfig> findFirstByRoomIdAndActiveIsTrue(Long roomId);

    @Modifying
    @Query("UPDATE PidConfig p SET p.active = false WHERE p.room.id = :roomId")
    void deactivateAllForRoom(@Param("roomId") Long roomId);
}


package diplom.work.storageservice.repository.room;

import diplom.work.storageservice.model.room.Room;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;

public interface RoomRepository extends JpaRepository<Room, Long> {
    List<Room> findAllByUserId(Long userId);
}


package diplom.work.storageservice.repository.sensor_data;

import diplom.work.storageservice.model.sensor_data.SensorData;
import jakarta.transaction.Transactional;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

import java.time.LocalDateTime;
import java.util.List;

public interface SensorDataRepository extends JpaRepository<SensorData, Long> {
    List<SensorData> findAllBySimulationId(Long simulationId);

    SensorData findTopBySimulationIdOrderByTimestampDesc(Long simulationId);

    Page<SensorData> findBySimulationId(
            Long simulationId,
            Pageable pageable);

    List<SensorData> findAllBySimulationIdOrderByTimestampAsc(Long id);

//    @Query("SELECT SUM(s.heaterPower) * 15.0 / (3600.0) " +
//            "FROM SensorData s " +
//            "WHERE s.roomName = :roomName AND s.id BETWEEN :startId AND :endId")
//    Double getConsumedEnergyKWh(@Param("roomName") String roomName,
//                                @Param("startId") Long startId,
//                                @Param("endId") Long endId);

}

package diplom.work.storageservice.repository.simulation;

import diplom.work.storageservice.model.simulation.Simulation;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

import java.util.List;

public interface SimulationRepository extends JpaRepository<Simulation, Long> {
    List<Simulation> findAllByRoomId(Long roomId);

    @Modifying
    @Query("""
           update Simulation s set s.status = :status
           where s.id = :id
           """)
    int updateStatus(@Param("id") Long id, @Param("status") Simulation.Status status);
}

package diplom.work.storageservice.repository.user;

import diplom.work.storageservice.model.user.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByUsername(String username);
    Optional<User> findByEmail(String username);
}

package diplom.work.storageservice.service.ai_model;

import diplom.work.storageservice.dto.ai_model.AiModelDTO;
import diplom.work.storageservice.model.ai_model.AiModel;
import diplom.work.storageservice.model.pid_config.PidConfig;
import diplom.work.storageservice.model.room.Room;
import diplom.work.storageservice.repository.ai_model.AiModelRepository;
import diplom.work.storageservice.repository.room.RoomRepository;
import diplom.work.storageservice.service.room.RoomService;
import diplom.work.storageservice.util.AiModelMapper;
import jakarta.persistence.EntityNotFoundException;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class AiModelService {
    private final AiModelRepository aiModelRepository;
    private final RoomService roomService;

    @Transactional
    public AiModel create(Long roomId, AiModel aiModel) {
        Room room = roomService.findRoomById(roomId)
                .orElseThrow(() -> new EntityNotFoundException("Room with id " + roomId + " not found."));
        aiModel.setRoom(room);
        return aiModelRepository.save(aiModel);
    }

    public List<AiModel> findAllModels() {
        return aiModelRepository.findAll();
    }

    public List<AiModel> findAllByRoom(Long roomId) {
        return aiModelRepository.findAllByRoomId(roomId);
    }

    public Optional<AiModel> findById(Long id) {
        return aiModelRepository.findById(id);
    }

    @Transactional
    public AiModel updateModel(Long modelId, AiModel updatedAiModel) {
        return aiModelRepository.findById(modelId)
                .map(aiModel -> {
                    Optional.ofNullable(updatedAiModel.getType()).ifPresent(aiModel::setType);
                    Optional.ofNullable(updatedAiModel.getPath()).ifPresent(aiModel::setPath);
                    Optional.ofNullable(updatedAiModel.getDescription()).ifPresent(aiModel::setDescription);
                    return aiModelRepository.save(aiModel);
                })
                .orElseThrow(() -> new EntityNotFoundException("AiModel with ID " + modelId + " not found"));
    }

    @Transactional
    public void deleteModel(Long modelId) {
        aiModelRepository.deleteById(modelId);
    }
}

package diplom.work.storageservice.service.pid_config;

import diplom.work.storageservice.dto.pid_config.PidConfigDTO;
import diplom.work.storageservice.model.ai_model.AiModel;
import diplom.work.storageservice.model.pid_config.PidConfig;
import diplom.work.storageservice.repository.pid_config.PidConfigRepository;
import diplom.work.storageservice.repository.room.RoomRepository;
import diplom.work.storageservice.service.room.RoomService;
import jakarta.persistence.EntityNotFoundException;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.NoSuchElementException;
import java.util.Optional;

@Service
@RequiredArgsConstructor
public class PidConfigService {
    private final PidConfigRepository pidConfigRepository;
    private final RoomService roomService;

    public List<PidConfig> findAllConfigs() {
        return pidConfigRepository.findAll();
    }

    /** Список всех конфигов комнаты */
    public List<PidConfig> findAllByRoom(Long roomId) {
        return pidConfigRepository.findByRoomIdOrderByIdDesc(roomId);
    }

    public Optional<PidConfig> findById(Long id) {
        return pidConfigRepository.findById(id);
    }

    /** Текущий активный конфиг */
    public Optional<PidConfig> getActive(Long roomId) {
        return pidConfigRepository.findFirstByRoomIdAndActiveIsTrue(roomId);
    }

    /** Создать новый конфиг вручную — деактивирует старые */
    @Transactional
    public PidConfig createManual(Long roomId, PidConfig pidConfig) {
        // Проверка, что комната существует
        var room = roomService.findRoomById(roomId).orElseThrow(
                () -> new EntityNotFoundException("Room with ID " + roomId + " not found."));
        System.out.println(room.getId());

        // Дезактивируем старые
        pidConfigRepository.deactivateAllForRoom(roomId);

        // Сохраняем новый
        pidConfig.setRoom(room);
        pidConfig.setActive(true);

        return pidConfigRepository.save(pidConfig);
    }

    /** Обновить существующий конфиг */
    @Transactional
    public PidConfig updateConfig(Long configId, PidConfig updatedPidConfig) {
        return pidConfigRepository.findById(configId)
                .map(config -> {
                    Optional.ofNullable(updatedPidConfig.getKp()).ifPresent(config::setKp);
                    Optional.ofNullable(updatedPidConfig.getKd()).ifPresent(config::setKd);
                    Optional.ofNullable(updatedPidConfig.getKi()).ifPresent(config::setKi);
                    Optional.ofNullable(updatedPidConfig.getTunedMethod()).ifPresent(config::setTunedMethod);
                    return pidConfigRepository.save(config);
                })
                .orElseThrow(() -> new EntityNotFoundException("Config with ID " + configId + " not found."));
    }

    /** Удалить конфиг */
    @Transactional
    public void deleteConfig(Long configId) {
        pidConfigRepository.deleteById(configId);
    }
}

package diplom.work.storageservice.service.room;

import diplom.work.storageservice.model.room.Room;
import diplom.work.storageservice.model.user.User;
import diplom.work.storageservice.repository.room.RoomRepository;
import diplom.work.storageservice.service.user.UserService;
import jakarta.persistence.EntityNotFoundException;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Optional;

@Service
@RequiredArgsConstructor
public class RoomService {
    private final RoomRepository roomRepository;
    private final UserService userService;

    @Transactional
    public Room create(Long userId, Room room) {
        var user = userService.findUserById(userId).orElseThrow(
                () -> new EntityNotFoundException("User with ID " + userId + " not found."));
        room.setUser(user);
        return roomRepository.save(room);
    }

    public List<Room> findAllRooms() {
        return roomRepository.findAll();
    }

    public List<Room> findAllByUser(Long userId) {
        return roomRepository.findAllByUserId(userId);
    }

    public Optional<Room> findRoomById(Long id) {
        return roomRepository.findById(id);
    }

    @Transactional
    public Room updateRoom(Long id, Room updatedRoom) {
        return roomRepository.findById(id)
                .map(room -> {
                    Optional.ofNullable(updatedRoom.getName()).ifPresent(room::setName);
                    Optional.ofNullable(updatedRoom.getRoomParams()).ifPresent(room::setRoomParams);
                    return roomRepository.save(room);
                })
                .orElseThrow(() -> new EntityNotFoundException("Room with ID " + id + " not found."));
    }

    @Transactional
    public void deleteRoom(Long roomId) {
        roomRepository.deleteById(roomId);
    }
}

package diplom.work.storageservice.service.sensor_data;

import diplom.work.storageservice.dto.sensor_data.SensorDataDTO;
import diplom.work.storageservice.model.sensor_data.SensorData;
import diplom.work.storageservice.util.SensorDataMapper;
import lombok.RequiredArgsConstructor;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.kafka.support.Acknowledgment;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class KafkaSensorDataListener {

    private final SensorDataService sensorDataService;
    private final SensorDataMapper sensorDataMapper;
    private final List<SensorDataDTO> buffer = Collections.synchronizedList(new ArrayList<>());

    private void addToBuffer(SensorDataDTO data) {
        buffer.add(data);
    }

    @Scheduled(fixedDelay = 5_000)  // запустить через 5 секунд после предыдущего окончания
    private void flushBuffer() {
        List<SensorDataDTO> toSave;
        synchronized (buffer) {
            if (buffer.isEmpty()) {
                return;
            }
            toSave = new ArrayList<>(buffer);
            buffer.clear();
        }
        // сохраняем пачкой
        // группируем по simulationId
        Map<Long, List<SensorDataDTO>> grouped = toSave.stream()
                .collect(Collectors.groupingBy(SensorDataDTO::simulationId));

        // Для каждой группы вызываем batch save
        grouped.forEach((simulationId, group) -> {
            List<SensorData> batch = group.stream()
                    .map(sensorDataMapper::toEntity)
                    .toList();
            sensorDataService.addBatch(simulationId, batch); // если нужно simulationId, передай сюда
        });
    }

    @KafkaListener(topics = "simulation-data-topic", groupId = "storage-group", containerFactory = "kafkaListenerContainerFactory")
    public void listenSensorData(SensorDataDTO data, Acknowledgment ack) {
        try {
            addToBuffer(data);
            ack.acknowledge();   // подтверждаем, что сообщение обработано успешно
        } catch (Exception ex) {
            // можно залогировать и пробросить, тогда errorHandler его поймает
            throw ex;
        }
    }
}

package diplom.work.storageservice.service.sensor_data;

import diplom.work.storageservice.dto.sensor_data.MetricsDTO;
import diplom.work.storageservice.model.sensor_data.SensorData;
import diplom.work.storageservice.repository.sensor_data.SensorDataRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.time.Duration;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

@Service
@RequiredArgsConstructor
public class MetricsService {

    private final SensorDataRepository repo;

    public MetricsDTO calc(long simulationId) {

        List<SensorData> rows =
                repo.findAllBySimulationIdOrderByTimestampAsc(simulationId);
        double dtSeconds = Duration.between(
                rows.get(0).getTimestamp(),
                rows.get(1).getTimestamp()
        ).toSeconds();

        List<Double> actualTemps = new ArrayList<>();
        List<Double> setpointTemps = new ArrayList<>();
        List<Double> powersKw = new ArrayList<>();

        for (SensorData row : rows) {
            actualTemps.add(row.getTempIn());
            setpointTemps.add(row.getTempSetpoint());
            powersKw.add(row.getHeaterPower() / 1000.0);
        }

        int n = actualTemps.size();
        if (setpointTemps.size() != n || powersKw.size() != n)
            throw new IllegalArgumentException("Усі списки мають бути однакової довжини");
        if (n == 0)
            throw new IllegalArgumentException("Порожні вибірки");

        double absSum = 0.0, sqSum = 0.0;
        for (int i = 0; i < n; i++) {
            double diff = actualTemps.get(i) - setpointTemps.get(i);
            absSum += Math.abs(diff);
            sqSum += diff * diff;
        }
        double mae = absSum / n;
        double mse = sqSum / n;
        double rmse = Math.sqrt(mse);

        double dtHours = dtSeconds / 3600.0;
        double energyKWh = 0.0;
        for (double p : powersKw) {
            energyKWh += p * dtHours;
        }

        double initialSp = setpointTemps.get(0);
        int stepIndex = 0;        // t0
        double newSetpoint = initialSp;

        for (int i = 1; i < n; i++) {
            if (!Objects.equals(setpointTemps.get(i), initialSp)) {
                stepIndex = i;
                newSetpoint = setpointTemps.get(i);
                break;
            }
        }
        double tolerance = 0.02 * newSetpoint;
        double maxTemp = actualTemps.stream()
                .skip(stepIndex)
                .mapToDouble(Double::doubleValue)
                .max()
                .orElse(newSetpoint);
        double overshoot = Math.max(0.0, maxTemp - newSetpoint);

        double settlingTimeS;
        {
            int settlingIndex = -1;
            outer:
            for (int i = stepIndex; i < n; i++) {
                if (Math.abs(actualTemps.get(i) - newSetpoint) > tolerance)
                    continue; 

                for (int j = i + 1; j < n; j++) {
                    if (Math.abs(actualTemps.get(j) - newSetpoint) > tolerance) {
                        continue outer;
                    }
                }
                settlingIndex = i;
                break;
            }

            if (settlingIndex < 0) {
                settlingTimeS = -1.0;
            } else {
                settlingTimeS = (settlingIndex - stepIndex) * dtSeconds;
            }
        }

        return new MetricsDTO(mae, mse, rmse, energyKWh, overshoot, settlingTimeS);
    }
}


package diplom.work.storageservice.service.sensor_data;

import diplom.work.storageservice.model.sensor_data.SensorData;
import diplom.work.storageservice.repository.sensor_data.SensorDataRepository;
import diplom.work.storageservice.service.simulation.SimulationService;
import jakarta.persistence.EntityNotFoundException;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

@Service
@RequiredArgsConstructor
public class SensorDataService {
    private final SensorDataRepository sensorRepository;
    private final SimulationService simulationService;

    public SensorData save(Long simulationId, SensorData data) {
        var simulation = simulationService.findSimulationById(simulationId).orElseThrow(
                () -> new EntityNotFoundException("Simulation with ID " + simulationId + " not found."));
        data.setSimulation(simulation);
        return sensorRepository.save(data);
    }

    public SensorData getLastBySimulationId(Long simulationId) {
        return sensorRepository.findTopBySimulationIdOrderByTimestampDesc(simulationId);
    }

    public List<SensorData> getAllBySimulationId(Long simulationId) {
        return sensorRepository.findAllBySimulationId(simulationId);
    }

    public Page<SensorData> getPage(Long simId, int page, int size) {
        Pageable pageable = PageRequest.of(page, size, Sort.by("id").ascending());
        return sensorRepository.findBySimulationId(simId, pageable);
    }

    @Transactional
    public void addBatch(List<SensorData> data) {
        sensorRepository.saveAll(data);
    }

    @Transactional
    public void addBatch(Long simulationId, List<SensorData> data) {
        var simulation = simulationService.findSimulationById(simulationId).orElseThrow(
                () -> new EntityNotFoundException("Simulation with ID " + simulationId + " not found."));
        List<SensorData> batchList = data.stream()
                .peek(sensor -> sensor.setSimulation(simulation))
                .toList();
        sensorRepository.saveAll(batchList);
    }
}

package diplom.work.storageservice.service.simulation;

import diplom.work.storageservice.model.simulation.Simulation;
import diplom.work.storageservice.repository.simulation.SimulationRepository;
import diplom.work.storageservice.service.room.RoomService;
import jakarta.persistence.EntityNotFoundException;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Optional;

@Service
@RequiredArgsConstructor
public class SimulationService {
    private final SimulationRepository simulationRepository;
    private final RoomService roomService;

    @Transactional
    public Simulation create(Long roomId, Simulation simulation) {
        var room = roomService.findRoomById(roomId).orElseThrow(
                () -> new EntityNotFoundException("Room with ID " + roomId + " not found."));
        simulation.setRoom(room);
        return simulationRepository.save(simulation);
    }

    public List<Simulation> findAllSimulations() {
        return simulationRepository.findAll();
    }

    public List<Simulation> findAllByRoom(Long roomId) {
        return simulationRepository.findAllByRoomId(roomId);
    }

    public Optional<Simulation> findSimulationById(Long id) {
        return simulationRepository.findById(id);
    }

    @Transactional
    public Simulation updateSimulation(Long id, Simulation updatedSimulation) {
        return simulationRepository.findById(id)
                .map(simulation -> {
                    Optional.ofNullable(updatedSimulation.getControllerType()).ifPresent(simulation::setControllerType);
                    Optional.ofNullable(updatedSimulation.getStatus()).ifPresent(simulation::setStatus);
                    return simulationRepository.save(simulation);
                })
                .orElseThrow(() -> new EntityNotFoundException("Simulation with ID " + id + " not found."));
    }

    @Transactional
    public Simulation setStatus(long id, Simulation.Status status) {
        if (simulationRepository.updateStatus(id, status) == 0) {
            throw new EntityNotFoundException("Simulation " + id + " not found");
        }
        return simulationRepository.findById(id).orElseThrow();
    }

    @Transactional
    public void deleteSimulation(Long simulationId) {
        simulationRepository.deleteById(simulationId);
    }
}

package diplom.work.storageservice.service.user;

import diplom.work.storageservice.model.user.User;
import diplom.work.storageservice.repository.user.UserRepository;
import jakarta.persistence.EntityNotFoundException;
import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.UUID;

@Service
@Transactional(readOnly = true)
@RequiredArgsConstructor
public class UserService {
    private final UserRepository userRepository;

    public List<User> findAllUsers() {
        return userRepository.findAll();
    }

    public Optional<User> findUserById(Long id) {
        return userRepository.findById(id);
    }

    public Optional<User> findByEmail(String email) {
        return userRepository.findByEmail(email);
    }

    public Optional<User> findByUsername(String username) {
        return userRepository.findByUsername(username);
    }

    @Transactional
    public User registerUser(User user) {
        return userRepository.save(user);
    }

    public User loginUser(String email, String rawPassword) {
        User dbUser = userRepository.findByEmail(email)
                .orElseThrow(() ->
                        new EntityNotFoundException("User with email %s not found".formatted(email)));

        if (!Objects.equals(rawPassword, dbUser.getPassword())) {
            throw new EntityNotFoundException("Password does not match");
        }
        return dbUser;
    }

    @Transactional
    public User updateUser(Long id, User updatedUser) {
        return userRepository.findById(id)
                .map(user -> {
                    Optional.ofNullable(updatedUser.getUsername()).ifPresent(user::setUsername);
                    Optional.ofNullable(updatedUser.getPassword()).ifPresent(user::setPassword);
                    Optional.ofNullable(updatedUser.getEmail()).ifPresent(user::setEmail);
                    return userRepository.save(user);
                })
                .orElseThrow(() -> new EntityNotFoundException("User with ID " + id + " not found"));
    }

    @Transactional
    public void deleteUser(Long userId) {
        userRepository.deleteById(userId);
    }
}

spring.application.name=StorageService
server.port=8082

spring.datasource.url=jdbc:postgresql://localhost:5433/storagedb
spring.datasource.username=postgres
spring.datasource.password=postgres

spring.jpa.hibernate.ddl-auto=update
spring.jpa.properties.hibernate.default_schema=simulations
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect

spring.datasource.hikari.connection-init-sql=SET NAMES 'UTF8'


CREATE SCHEMA simulations;

CREATE TABLE users
(
    id            SERIAL PRIMARY KEY,
    username      VARCHAR(128) UNIQUE NOT NULL,
    email         VARCHAR(128) UNIQUE NOT NULL,
    password_hash TEXT
);

CREATE TABLE rooms
(
    id          SERIAL PRIMARY KEY,
    name        VARCHAR(32)               NOT NULL,
    room_params JSONB                     NOT NULL,
    user_id     INT REFERENCES users (id) NOT NULL
);

CREATE TABLE pid_configs
(
    id           SERIAL PRIMARY KEY,
    kp           DOUBLE PRECISION          NOT NULL,
    ki           DOUBLE PRECISION          NOT NULL,
    kd           DOUBLE PRECISION          NOT NULL,
    tuned_method VARCHAR(32),
    room_id      INT REFERENCES rooms (id) NOT NULL,
    is_active    BOOLEAN DEFAULT TRUE
);

CREATE TABLE simulations
(
    id              SERIAL PRIMARY KEY,
    room_id         INT REFERENCES rooms (id) NOT NULL,
    controller_type VARCHAR(32),
    status          VARCHAR(32),
    iterations BIGINT NOT NULL DEFAULT 0,
    timestep_seconds INT NOT NULL DEFAULT 1
);

CREATE TABLE simulation_events
(
    id             BIGSERIAL PRIMARY KEY,
    simulation_id  INT REFERENCES simulations (id) NOT NULL,
    timestamp      TIMESTAMP,
    temp_in        DOUBLE PRECISION,
    temp_out       DOUBLE PRECISION,
    temp_setpoint  DOUBLE PRECISION,
    heater_power   DOUBLE PRECISION,
    predicted_temp DOUBLE PRECISION,
    is_window_open BOOLEAN,
    is_door_open   BOOLEAN,
    people_count   INT
);

CREATE TABLE models
(
    id      SERIAL PRIMARY KEY,
    room_id INT REFERENCES rooms (id) NOT NULL,
    type    VARCHAR(16) NOT NULL,
    path    TEXT,
    description TEXT,
    is_active    BOOLEAN DEFAULT TRUE
);





































